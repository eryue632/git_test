 

# 算法

https://www.zybuluo.com/codeep/note/163962#cmd-markdown-%E5%85%AC%E5%BC%8F%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C



### 报错

```c++
bool operator <(struct node &b)const
{
    return r-l<b.r-b.l;//等号可能会错
}
```

# 比赛模板

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define il (i<<1)
#define ir (i<<1)+1
#define pb push_back
const int maxn=1e5+5;
inline char nc() {static char buf[1000000],*p1=buf,*p2=buf;return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;}
inline void read(int &sum) {char ch=nc();sum=0;while(ch<'0') ch=nc();while(ch>='0') sum=(sum<<3)+(sum<<1)+(ch^48),ch=nc();}
ll qsm(ll a,ll b)
{
	ll base=a,ans=1;
	while(b>0)
	{
		if(b%2==1)ans=ans*base;
		base=base*base;
		b>>=1;
	}
	return ans;
}
ll gcd(ll a,ll b)
{
	return b==0?a:gcd(b,a%b);
}
void solve()
{
	
}
int main()
{
	ios::sync_with_stdio(false);
	int t;
	cin>>t;
	while(t--)sovle();
	return 0;
}
```





##  STL

#### unordered_mapPostgraduate entrance examinatio

ceil()向上取整

floor()向下取整

### __builtin_popcount()

用于一个数字的二进制中有多少个1.

### bitset

```c++
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const LL mod = 1000000007;
const int MX = 1e3+1;
bitset<100*100*100+1>ans,t;
int main(){
    int n;scanf("%d",&n);
    ans[0]=1;
    while(n--){
        t.reset();
        int l,r;scanf("%d%d",&l,&r);
        while(l<=r){
            t|=ans<<(l*l);l++;
        }
        ans=t;
    }
    printf("%d",ans.count());
    return 0;
}
```

### 对拍

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read()
{
	ll ret=0;char ch=' ',c=getchar();
	while(!(c<='9'&&c>='0')) ch=c,c=getchar();
	while(c<='9'&&c>='0') ret=(ret<<1)+(ret<<3)+c-'0',c=getchar();
	return ch=='-'?-ret:ret;
}
int main()
{
	for(int i=1;i<=10000;i++)
	{
		system("data.exe>data.txt");
		system("E.exe<data.txt>E.txt");
		double st=clock();
		system("e.exe<data.txt>p.txt");
		double ed=clock();
		if(system("fc E.txt p.txt")) {printf("WA\n");break;}
		else printf("AC #%d Time:%.3lfms\n",i,ed-st);
	}
	return 0;
}

```



### 字符串操作

```c++
getline(cin,s);
to_string();
stoi/stol/stoll;
```

### 优先队列

```c++
#include<bits/stdc++.h>
#define maxn 200005
#define ll long long
using namespace std;
ll a[maxn],sum[maxn];
int n;
bool check(ll x,ll y)
{
	ll t=y;
	for(ll i=min((ll)n-1,x);i>=0;i--)
	{
		ll p=a[1]-(x-i),g=a[1]-p+(sum[n]-sum[n-i])-p*i;
		t=min(t,y-g);
	}
	return t<=0;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int T; cin>>T;
	while(T--)
	{
		ll k; cin>>n>>k;
		for(int i=1;i<=n;i++) cin>>a[i];
		sort(a+1,a+n+1);
		for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];
		if(sum[n]<=k) {cout<<0<<'\n'; continue;}
		ll l=1,r=a[1]+n-1,ans=a[1]+n-1;
		while(l<=r)
		{
			ll mid=l+r>>1;
			if(check(mid,sum[n]-k)) ans=mid,r=mid-1;
			else l=mid+1;
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

### pair

震惊，map竟然是用pair 实现的。

```c++
#include <iostream>
#include <string>
#include <utility>
#include <map>

using namespace std;

int main() {	
	pair<string, string> p1("sc0301","小杨");	            // 方式一，创建一个pair名为p1
	pair<string, string> p2 = make_pair("sc0302", "小马");	// 方式二，make_pair函数返回一个用"sc0302"和 "小马"初始化的pair
	pair<string, string> p3("sc0303", "小王");
	pair<string, string> p4("sc0304", "小何");

	map<string, string> m1;                 // 创建一个空map
	map<string, string> m2{ p1,p2,p3,p4 };  // 创建一个包含pair p1、p2、p3、p4的map
	map<string, string> m3{ {"sc0301","小杨"},{"sc0302", "小马"},{"sc0303", "小王"},{"sc0304", "小何"} }; // 效果同上一句

	map<string, string>::iterator it1 = m2.begin();	 // 得到指向m2首元素的迭代器
	map<string, string>::iterator it2 = m2.end();    // 得到指向m2尾元素的下一个位置的迭代器
	pair<string, string> p11 = *it1;   // 得到m2的首元素{"sc0301","小杨"}，这是一个pair
	string p1_ID = it1->first;         // 得到m2的首元素{"sc0301","小杨"}的fisrt成员，学号
	string p1_name = it1->second;	   // 得到m2的首元素{"sc0301","小杨"}的second成员，姓名


	for (auto p : m2) {
		cout << "学号：" << p.first << "; 姓名:" << p.second << endl;
	}

	m1.insert(p1);	                   // 在map中插入已有的pair
	m1.insert({ "sc0302", "小马" });   // 插入键值对{ "sc0302", "小马" }
	m1.insert(pair<string, string> ("sc0303", "小王"));  // 创建一个无名pair对象，并插入到map中	
	m1.emplace(p1);			                             // 要插入的关键字已在容器中，emplace/insert什么都不做
	m1.emplace(pair<string, string>("sc0303", "小王"));  // 要插入的关键字已在容器中，emplace/insert什么都不做

	map<string, string>::iterator it = m2.find("sc0301");  // 查找关键字为"sc0301"的元素,返回一个迭代器
	if (it == m2.end()) {         // 若"sc0301"不在容器中，则it等于尾后迭代器
		cout << "未找到！" << endl;
	}
	else {
		pair<string, string> result1 = *it;	// 找到了
	}

	int result2 = m2.count("sc0305");  // 查找关键字为"sc0301"的元素,返回关键字等于"sc0301"的元素数量
	if (result2==0) {
		cout << "未找到！" << endl;
	}
	else {
		cout << "找到了！" << endl;
	}
}

```



### sort排序

```c++
struct cmp
     {
           bool operator()(int a,int b)
          {
               return dist[a]>dist[b];
          }
    };
friend <返回类型> <函数名> (<参数列表>);
friend bool operator<(const node &a,const node  &b)
{
	return a.x<b.x;
}
bool operator<(node &a)const
{
	return y<b.y;//y表示当前结构体的值
}
//**优先队列相反**
```

### vector

```	c++
vector<type> name;
a.clear(); //清空a中的元素
a.back(); //返回a的最后一个元素
a.front(); //返回a的第一个元素
vect.size();返回容器中元素的个数
vect.empty();判断容器是否为空
a.insert(a.begin()+1,5); //在a的第1个元素（从第0个算起）的位置插入数值5，
如a为1,2,3,4，插入元素后为1,5,2,3,4
vect.resize(num);重新指定容器的长度为num，若容器变长，则以默认值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。
vect.resize(num,elem);重新指定容器的长度为num，若容器变长，则以elem值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。
vect.push_back(1);//在vector最后添加元素1
a.swap(b); //b为向量，将a中的元素和b中的元素进行整体性交换
vect.pop_back()//删除最后一个元素
vector<int> vect(a,a+10);//将数组a整体插入；
 sort(vect.begin(),vect.end());
for(int i=0;i<=b.size()-1;i++)
```

### set

```c++
begin()     //返回set容器的第一个迭代器
end() 　　　//返回set容器的最后一个迭代器
clear()   　//删除set容器中的所有的元素
empty() 　//判断set容器是否为空
max_size() //返回set容器可能包含的元素最大个数
size() 　　　//返回当前set容器中的元素个数
rbegin　　　//返回的值和end()相同
rend()　　　//返回的值和rbegin()相同
```

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 5;
int a[maxn];
int main() {
	int n, q;
	cin >> n >> q;
	set<int>s;
	while (q--)
	{
		int op, id;
		cin >> op >> id;
		s.insert(0); s.insert(n);
		if (op == 1)s.insert(id);
		else
		{
			set<int>::iterator it;
			it = s.lower_bound(id);
			int len = *it - *(--it);
			cout << len << endl;
		}
	}
	return 0;
}
```



### 二分查找

```c++
upper_bound：
//在一个已排序的序列中[first, last)，返回第一个大于val的元素所在的地址。如果未找到结果，则返回last；
lower_bound：
//在一个已排序的序列[first, last), 返回第一个大于等于val元素的地址,如未找到，则返回last；
binary_search：
//在一个已排序的序列[first, last)中， 判断val是否存在;
```

### unique

3 3 2 5 2 3 -》 3 2 5 2 3 3 

## python黑科技

### eval()函数

可以直接求字符串表达式的值注意：“^”转“**”；

```py
s = input()
s1=""
for i in range(len(s)):
    if s[i]=="^" :
        s1=s1+"**"
    else :
        s1=s1+s[i]
print(eval(s1))
```



## 常用函数

### 最 da公约数

```c++
ll gcd(ll a,ll b){
    return b==0?a:gcd(b,a%b);
}
== __gcd()
```

### 快速幂

```c++
ll qsm(ll a,ll b)
{
    ll base=a,ans=1;
    while(b>0)
    {
        if(b%2==1)ans=ans*base;
        base=base*base;
        b>>=1;
    }
    return ans;
}
```

## 动态规划

### 数位dp

技巧 1：如果是从1->n,那么可以将区间问题转化为f(n)-f(m-1);

技巧2：利用数形结构来分析问题,注意last转移时的条件

```c++
typedef long long ll;
int a[20];
ll dp[20][state];//不同题目状态不同
ll dfs(int pos,/*state变量*/,bool lead/*前导零*/,bool limit/*数位上界变量*/)//不是每个题都要判断前导零
{
    //递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了
    if(pos==-1) return 1;/*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。不过具体题目不同或者写法不同的话不一定要返回1 */
    //第二个就是记忆化(在此前可能不同题目还能有一些剪枝)
    if(!limit && !lead && dp[pos][state]!=-1) return dp[pos][state];
    /*常规写法都是在没有限制的条件记忆化，这里与下面记录状态是对应，具体为什么是有条件的记忆化后面会讲*/
    int up=limit?a[pos]:9;//根据limit判断枚举的上界up;这个的例子前面用213讲过了
    ll ans=0;
    //开始计数
    for(int i=0;i<=up;i++)//枚举，然后把不同情况的个数加到ans就可以了
    {
        if() ...
        else if()...
        ans+=dfs(pos-1,/*状态转移*/,lead && i==0,limit && i==a[pos]) //最后两个变量传参都是这样写的
        /*这里还算比较灵活，不过做几个题就觉得这里也是套路了
        大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论
        去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目
        要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类，
        前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/
    }
    //计算完，记录状态
    if(!limit && !lead) dp[pos][state]=ans;
    /*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/
    return ans;
}
ll solve(ll x)
{
    int pos=0;
    while(x)//把数位都分解出来
    {
        a[pos++]=x%10;//个人老是喜欢编号为[0,pos),看不惯的就按自己习惯来，反正注意数位边界就行
        x/=10;
    }
    return dfs(pos-1/*从最高位开始枚举*/,/*一系列状态 */,true,true);//刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛
}
int main()
{
    ll le,ri;
    while(~scanf("%lld%lld",&le,&ri))
    {
        //初始化dp数组为-1,这里还有更加优美的优化,后面讲
        printf("%lld\n",solve(ri)-solve(le-1));
    }
}
```



度的数量

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn = 1e6 + 6;
ll dp[64][64];
ll a[64],k,base;
ll dfs(int pos,int sta,int limt)
{
	if (sta == 0)return 1;
	if (pos == 0)return 0;
	if (!limt&&dp[pos][sta] != -1)return dp[pos][sta];
	int up = limt&&a[pos]==0?0:1;//控制上限
	ll ans = 0;
	for(int i=0;i<=up;i++)
	{
		 ans += dfs(pos - 1, sta - (i==1), limt&&i == a[pos]);
	}
	if (limt)return ans;
	dp[pos][sta] = ans;
	return ans;
}
ll get(ll x)
{
	ll cnt = 0;
	while(x)
	{
		a[++cnt] = x % base;
		x /= base;
	}
	return dfs(cnt, k, 1);//初始时limt=1;
}
int main()
{
	ios::sync_with_stdio(false);
	ll l, r;
	cin >> l >> r >> k>>base;
	memset(dp, -1, sizeof dp);
	cout << get(r) - get(l - 1)<<endl;

	return 0;
}
```

数位小孩(前导零)

```python
#include<bits/stdc++.h>
using namespace std;
#define int long long
int dp[15][10][2][2], a[15];
int isp[] = { 0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0 };
int dfs(int pos,int sta1,int sta2,int lead,int limit)
{
	if (pos == 0 && sta2 && lead== 0)return 1;
	if (pos == 0)return 0;
	if (!limit &&dp[pos][sta1][sta2][lead] != -1)return dp[pos][sta1][sta2][lead];
	int up = limit ? a[pos] : 9;
	int ans = 0;
	for(int i=0;i<=up;i++)
	{
		if (lead == 0 && isp[i + sta1] == 0)continue;
		ans += dfs(pos - 1, i,sta2|(i==1), lead&&i == 0, limit&&i == a[pos]);
	}
	if (!limit)return dp[pos][sta1][sta2][lead] = ans;
	return ans;
}
int get(int x)
{
	int cnt = 0;
	while (x)
	{
		a[++cnt] = x % 10;
		x /= 10;
	}
	return dfs(cnt, 0, 0, 1, 1);
}
signed main()
{
	int l, r;
	cin >> l >> r;
	memset(dp, -1, sizeof dp);
	cout<<get(r)-get(l-1)<<endl;
	//cout << get(r) << endl;
	//cout<<get(l-1)<<endl;
	return 0;
}
```



## 背包问题

背包问题一定是dp？

no！暴力搜索也能过背包问题，dp类似于记忆化搜索，如何有效利用已经被记录的信息是问题关键，如何保持信息的后续有效性也是关键。

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=3e4;
const int maxm=26;
int v[maxn],w[maxn],n,m,res=0,dp[maxm][maxn];
int dfs(int i,int j)
{
	if(dp[i][j]!=-1)return dp[i][j];
	if(i==m)
	{
		return 0;
	}
	else if(j<v[i])res=dfs(i+1,j);
	else 
	{
		res=max(dfs(i+1,j),dfs(i+1,j-v[i])+v[i]*w[i]);
		dp[i][j]=res;
	}
	return res;
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=0;i<m;i++)cin>>v[i]>>w[i];
	memset(dp,-1,sizeof(dp));
	dfs(0,n);
	cout<<res<<endl;
	return 0;
}
```



### 01背包问题

一维数组需要逆序

二维需要对不操作的传递

 bag[j]=maxv(bag[j],bag[j-w[i]]+v[i]);

### 完全背包问题

一维数组需要正序

maxValue[j] = max(maxValue[j], maxValue[j-w[i]] + v[i]);

### 多重背包问题

本质与01背包没有什么不同

### 分组背包问题

增加一维表示组别，保证只在这一组中选一个或者不选



## 数论

#### 排列组合



### 同余问题

**定义**：同余给定整数m,若用m去除两个整数a和b所得的余数相同，称a和b对模m同余，记作$a\equiv \ b(mod\ m)$​。

**定理1**  $a\equiv b(mod\ m)$当且仅当$m|(a-b)$

**定理2**   $a\equiv b(mod\ m)$当且仅当存在k满足$a=b+km$

**定理3**  同余关系是等价关系

**定理4** 若a, b, c是整数，m是整数，且$a\equiv b(mod\ m)$，则：
$$
a+c\equiv a+c(mod\ m)\\
a-c\equiv a-c(mod\ m)\\
ac\equiv bc (mod \ m)
$$
**定理5** 设a,b,c,d,为整数，m为正整数，若$a\equiv b (mod\ m)$，$c\equiv d(mod\ m)$,则
$$
ax+cy\equiv bx+dy(mod\ m)(即可加性)\\
ac\equiv bd(mod\ m)(可乘性)\\
a^n\equiv b^n(mod\ m)(可幂性)\\
f(a)\equiv f(b)(mod\ m)(f(x)为任意整数多项式)
$$
（ps:同余的性质十分稳定，具有线性。

**定理6** 设a,b,c,d为整数，m为正整数,则

+ 若$a\equiv b(mod\ m)$，且d|m,则$a\equiv b (mod\ d)$。(ps:当两数对m同余，对于m的因子也同余)
+ 若$a\equiv b(mod\ m)$，则$gcd(a,m)=gcd(b,m)$​
+ $a\equiv b (mod\ m_i),i=1,2,\dots,n$成立，当且仅当$a\equiv b (mod[m_1,m_2,\dots,m_n])$.

定理7 若$ac\equiv bc(mod \ m),d=gcd(c,m)$,则$a\equiv b (mod \ m/d)$

### 扩展欧几里得

**贝祖定理**：如果a\b是整数，那么一定存在整数x,y使得$ax+by=gcd(a,b)$​有解

推论：如果$ax+by=1$有解，那么$gcd(a,b)=1$

```c++
int exgcd(int a, int b, int &x0, int &y0)
{
    if(!b)
    {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a%b, y0, x0);
    y -= a/b*x;
    return d;
}
int main()
{
    int a, b;
    cin >> a >> b;
    int x0, y0;
    cout<<exgcd(a, b, x0, y0 )<<endl;
    cout<<(x%b+b)%b<<endl;
    return 0;
}
```

该函数的返回值为a和b的最大公因数d，其中x,y为其中一组解。

一次同余方程ax + by = c 有解的充要条件为$gcd(a,b)|c$

当$gcd(a,b)|c$是同余方程有$gcd(a,n)$个解

$x = x_0 +k*\frac{b}{d}$

$y = y_0 -k*\frac{a}{d}$



### 欧拉函数

欧拉函数的定义

$\phi (n) $ 表示在1到n中，与n形成互质关系的数的个数。

欧拉函数的性质

+ 当n为质数时，$\phi(n)=n-1$

+ 欧拉函数是积性函数，但不是完全积性函数

  只有当$n=p_1*p_2$ 时，$\phi(n)=\phi(p_1)*\phi(p_2)$

  $\phi(pq)=\phi(q)*\phi(p)=(p-1)(q-1)$(RSA算法应用)

+ 当n>2时，$\phi(n)$为偶数

当n为质数的k次幂时，$\phi(n)=p^k-p^{k-1}=(p-1)p^{k-1}$

证明，只用当数x为p的倍数时，两者才不互质，易得这类数的数量为$p^{k-1}$。

通过以上的理论可以得到以下公式，
$$
\phi(N) = N*\prod_{i=1}^{n}(1-\frac{1}{p_i})
$$
其中pi为质因子，即每个质因子只算一次。

o(n)的筛法筛出质数的同时求得其函数值

需要用到如下性质：

设p为质数

如果p为x的因数

那么$\phi(p*x)=p*x*(1-\frac{1}{p_1})*(1-\frac{1}{p_2})*...(1-\frac{1}{p_n}))=\phi(x)*p$

如果p不是x的因数，即px互质

那么$\phi(p*x)=\phi(p)*\phi(x)=\phi(x)*(p-1)$

```cpp
phi[1]=1;
for(int i=2;i<=maxn;i++)
	{
		if(!isprime[i])
		{
			prime[++cnt]=i;
			phi[i]=i-1;//质数直接能求出
		}
		for(int j=1;j<=cnt&&prime[j]*i<=maxn;j++)
		{
			isprime[i*prime[j]]=1;
			if(i%prime[j]==0)
			{
				phi[i*prime[j]]=phi[i]*prime[j];//px不互质
				break;
			}
			else phi[i*prime[j]]=phi[i]*(prime[j]-1);//px互质
		}
	}

```

样例：

6 2

20 8

30 8

100 40

### 欧拉定理 


$$
a^{\phi(n)}\equiv1(mod\ n)\\
s.t.\ gcd(a,n)=1
$$
费马小定理
$$
a^{p-1}\equiv1(mod\ p)
$$
由欧拉函数可知费马小定理为欧拉定理的特殊情况。



### 约数个数及约数和

当处理因子时，应当反向思考处理倍数。

d(n)为正整数n的因子个数。

$sum(n)$为约数之和
$$
d(n) = (\alpha_1+1)*(\alpha_2+1)*...*(\alpha_k+1)
\\ \sum_{i=1}^{i=质数个数}\sum_{j=0}^{j=p_i的最大次幂} p_i^{j}
$$


N 在 2e9中，因子数最多1600个

### 中国剩余定理

中国剩余定理是对**符合特定条件的线性同余方程组**进行求解

中国剩余的解为构造解，非推理解

若$m_1,m_2,m_3,...,m_r$是两两互素的正整数，则同余方程
$$
x\equiv a_1(mod \ m_1)\\
x\equiv a_2(mod\ m_2)\\
x\equiv a_3(mod\ m_3)\\
\dots\\
\dots\\
x\equiv a_r(mod\ m_r)
$$
有模$M=m_1m_2m_3*\dots*m_r$​​​的唯一解，即为中国剩余定理。

求解思路：

+ 令$M_i=M/m_i$由于$m_i,m_j$互质，因此$gcd(M_i,m_i)=1$,即$M_iP_i\equiv 1 (mod\ m_i)$,满足扩展欧几里得的求解。
+ $res=a_1M_1P_1+a_2M_2P_2+\dots+a_rM_rP_r$​​​​ ，res即为最小解

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll exgcd(ll a, ll b, ll &x, ll &y)
{
	if(b==0)
	{
		x = 1, y = 0;
		return a;
	}
	ll d = exgcd(b, a%b, y, x);
	y -= a/b*x;
	return d;
} 
int main()
{
	int n;
	cin>>n;
	vector<ll>A(n+1),B(n+1);
	ll M=1ll,res=0;
	for(int i=1;i<=n;i++)cin>>A[i]>>B[i],M*=A[i];
	for(int i=1;i<=n;i++)
	{
		ll x, y;
		exgcd(M/A[i], A[i], x, y);//求逆元
		res = (res + B[i]*M/A[i]*x)%M;
	}
	cout<<(res+M)%M<<endl;
}
```



### 康托展开

康托展开问题：

给定一个长度为n的排列，问该排列在全排列中的位置，例如：

123 1

132 2

213 3

231 4

312 5

312 6

这是将全排列与整数相映射，形成双射函数。

核心思想：数位dp分叉思想，当前**未在之前出现**比**当前位小**的数不论之后如何排列，都要比该数小。

具体求解步骤：

+ 预处理处阶乘数组
+ 开始分叉处理，因为要知道有几个数未曾出现并且比当且数小，所以可以利用树状数组优化。
+ 总时间复杂度$o(nlog_n)$​

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=998244353;
const int maxn=1e6+5;
ll jc[maxn],c[maxn];
inline int lowbit(int x)//树状数组
{
	return x&(-x);
}
inline void updata(int x,int y,int n)
{
	for(int i=x;i<=n;i+=lowbit(i))c[i]+=y;
}
inline ll getsum(int x)
{
	ll ans=0;for(int i=x;i>0;i-=lowbit(i))ans+=c[i];
	return ans;
}
void pre_jc()//预处理阶乘
{
	ll num=1;jc[0]=1;
	for(ll i=1;i<maxn;i++)
	{
		num=(num*i)%mod;
		jc[i]=num;
	}
}
int main()
{
	ios::sync_with_stdio(false);
	pre_jc();
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)updata(i,1,n);
	ll res=0;
	for(int i=1;i<=n;i++)
	{
		int num;cin>>num;
		getsum(num-1);
		res=(res+getsum(num-1)*jc[n-i]%mod)%mod;//核心代码
		updata(num,-1,n);
	}
	cout<<(res+1)%mod<<endl;//res是有多少比自己小，所以要加1 
	return 0;
}
```

### Burnside 定理与Polya定理

给定一个n格的环，m涂色,有多少种本质不同的方案

一般可以证明：当只有旋转的时候(顺时针或逆时针)，对于一个有n个字符的环，可顺时针或逆时针旋转几个位置，由于至少有n个置换，但是假设我顺时针旋转k个位置，他就等同于逆时针转动n-k个位置，假设一个置换为:G={π0，π1，π2，π3，π4，...，πn-1}，这个时候可以证明逆时针旋转k个位置时πk的循环节的个数为Gcd(n,k)，且每个循环的长度为L=n/gcd(n,i)。

Polya 定理得
$$
answer = \frac{\sum_{i=1}^{n}m^{gcd(i,n)}}{n}
$$


### 组合数

当数据范围小于等于3000 30003000左右时，可直接根据组合数的一个性质：C ( n , m ) = C ( n − 1 , m ) + C ( n − 1 , m − 1 ) 直接递推计算，时间复杂度为 O(n^2).

o(n^2)求组合数。

```c++
for(int i=0; i<=n; i++) {
		c[i][0]=1;
		for(int j=1; j<=i; j++) {
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
		}
	}
```



### 高精取模

```
int b[N],n; //高精度数，表示n
int ksm(int a,int m) {
	int ans=1;
	for(int i=0;i<n;++i) {
		for(int j=0;j<b[i];++j) ans=1ll*ans*a%m;
		int tmp=1;
		for(int j=0;j<10;++j) tmp=1ll*tmp*a%m;
		a=tmp;//乘十次
	}
	return ans;
} 
```



### 筛法

1e6中有80000个素数

1.普通素数筛

时间复杂度n2

2.埃斯筛

时间复杂度(nloglog n)

```c++

```

3.欧拉筛

时间复杂度o(n)

```c++
int a[maxn],b[maxn],c[maxn],ans=0;
for(int i=2;i<maxn;i++)
{
    if(a[i]==0)b[++ans]=i;
    for(int j=1;i*b[j]<maxn&&j<=ans;j++)
    {
        a[i*b[j]]=1;c[i*b[j]]=c[i]+1;
        if(i%b[j]==0)break;
    }
}
```

4.min25筛

空间n^0.5 时间为（n^0.75/ln n +n/poly(ln n)）一秒1e10;

```c++
//问题描述定义：
//定义sigma(n)为n的正因数的数量，求f(n,k)=sum_{i=1}^n (sigma(i^k))
#include<stdio.h>
#include<math.h>

using namespace std;
typedef unsigned long long ull;
typedef long long ll;

const int N=200005;

int T,S,pr[N],pc;
ll n,num[N],m,K;
ull g[N];
bool fl[N];
// 给定一个数字X求出其为第几个可以得到有效的g的数字
inline int ID(ll x){return x<=S?x:m-n/x+1;}

ull f(ll n,int i){
    if(n<1||pr[i]>n)return 0;
    ull ret=g[ID(n)]-(i-1)*(K+1);
    while((ll)pr[i]*pr[i]<=n){
        int p=pr[i];
        ull e=K+1,t=n/p;
        while(t>=p)ret+=f(t,i+1)*e+e+K,t/=p,e+=K;
        // ret= sum{sigma(p^es)([n>1]+f(n/p^es,p)+g[n]-g[num[i-1]]}
        // 因为对于函数g(n,m)当n<=m^2,g(n,m)为0
        // 且根据sigma函数的性质，对于质数p，有sigma(p^es)=es*k+1
        // 所以 ret+=(es*k+1)*f(n/p^es,p)+((es+1)k+1)(1<=es&& n/p^es>p)即当前项的sigma(p^e)*f(n/p^e,p)加上下一项的sigma(p^e)
        // 这样的做法避免了e<1也就不必进行特判
        i++;
    }
    return ret;
}
//g[i]即小于i的所有质数的sigma函数求和
//根绝前面的推导，只有当i可以通过[n/m]得到时，其才有用
ull solve(ll n){
    int i,p,x;ull y;
    S=sqrt(n);
    while((ll)S*S<=n)S++;
    while((ll)S*S>n)S--;
    while(m)num[m--]=0;
    for(i=1;i<=S;i++)num[++m]=i;
    for(i=S;i>=1;i--)if(n/i>S)num[++m]=n/i;
    for(i=1;i<=m;i++)g[i]=num[i]-1;
    //此处g[i]为小于等于第i个满足可以通过[n/m]得到的数的素因子的数量
    //故先减去“1”因为1一定不为素因子且无法被后续操作筛去
    x=1;y=0;
    for(p=2;p<=S;p++)if(g[p]!=g[p-1]){
        while(num[x]<(ll)p*p)x++;
        //令g'(i,j)为埃氏筛法筛出前j个素数后，1到j之间剩余数的数量
        //则有g'(i,j)=g'(0,j)-sum_{k=0,k<i}(g'(k,[j/p[k+1]])-g'(k,p[k]))
        //其中p[0]=1,p[i](i>0)为第i个质数
        //则g(j)即为g'(i,j)使得有p[i]<j&&p[i+1]>j
     
        //其中g'(k,p[k])即为k+1
        //由于以上的递推式仅仅作用到num[x]>=p^2为止，故仅仅将更新到x
        //由于每次都要减去尚未去除当前素数的g以充当g'因此从大往小更新
        for(i=m;i>=x;i--)g[i]-=g[ID(num[i]/p)]-y;
        y++;
    }
    for(i=1;i<=m;i++)g[i]*=K+1;
    return f(n,1)+1;
}

int main(){
    int i,j;
    //素数筛
    for(i=2;i<N;i++)if(!fl[i]){
        pr[++pc]=i;
        for(j=i+i;j<N;j+=i)fl[j]=1;
    }
    for(scanf("%d",&T);T--;){
        scanf("%lld%lld",&n,&K);
        printf("%llu\n",solve(n));
    }
    return 0;
}

```



### 三分查找

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=16;
const double eps=1e-7;
double a[maxn];
int n;
double f(double x)
{
	double res=0,xx=1;
	for(int i=0;i<=n;i++)
	{
		res+=a[i]*xx;xx*=x;
	}
	return res;
}
int main()
{
	double l,r;
	cin>>n>>l>>r;
	for(int i=0;i<=n;i++)
	{
		cin>>a[n-i];
	}
	//for(int i=0;i<=n;i++)cout<<a[i]<<" ";cout<<endl;
	while((r-l)>eps)
	{
		double midl=(r-l)/3+l,midr=r-(r-l)/3;
		double ansl=f(midl),ansr=f(midr);
		if(ansr>ansl)l=midl;
		else if(ansl>ansr)r=midr;
		else l=midl,r=midr;	
	}
	//cout<<f(-4.1)<<" "<<f(-4.9)<<endl;
	cout<<l<<endl;
	
	return 0;
}
```

整型的三分

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
#include <math.h>
#include <map>
#include <set>
#include <queue>

using namespace std;
#define endl '\n'
#define ll long long
#define int long long
const int maxn = 2e5 + 5;
int n,a[maxn];
ll b[maxn],c[maxn];
ll check(int x){
    ll res = 0;
    for (int i = 1; i < n; ++i) {
        c[i] = c[i - 1] + x - b[i + 1];
    }
    nth_element(c,c + n / 2,c + n);
    ll mid = c[n / 2];
    for (int i = 0; i < n; ++i) {
        ll y = mid - c[i];
        res += abs(y);
    }
    return res;
}
signed main(){
    std::ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; ++i) {
        b[i] = a[i] - a[i - 1];
    }
    int l = -1e13,r = 1e13;
    if (n > 2e3) l /= n / 10 ,r /= n / 10;
    while (l < r){
        int midl = l + (r - l) / 3;
        int midr = r - (r - l) / 3;
        if (check(midl) <= check(midr)) r = midr - 1;
        else l = midl + 1;
    }
    cout << check(l);
}
```



### 约瑟夫问题

首先，对于经典的约瑟夫环问题，我们记f(n,m)表示初始有n 个人，第m 个出队的人是谁（从0号开始报数）。则有递推式f(n,m)=(f(n−1,m−1)+k) % n 其中k表示每报数k次一个人出队，注意编号从0开始。




### 莫比乌斯反演

莫比乌斯反演实际上是一两个公式定理的运用，自认为想要掌握它的话，其中的证明还是有必要了解的。看过网上一些博客，感觉都只证明了一半，没看到有人将这个定理完全证明出来。然而我最近在正好在学习初等数论，发现完全证明这个定理实际上并不需要很多知识，特此填坑。

实际上，这个定理的证明用到了一点数论函数相关知识。前置技能在此

https://blog.csdn.net/tomandjake_/article/details/81083051

内容并不多，自认为把这一页笔记内容学会，自己就可以把莫比乌斯反演的证明当练习题一样独立完成。接下来我还是会解释，当然，如果觉得我的解释不好，完全可以自己看这个笔记学习，我甚至都推荐自己看笔记，因为如果熟悉这样的数学语言，其实看的很快而且会有自己的认识。而且其中给出了欧拉函数的推导，没有学过欧拉函数的话，看这个也可以更加高效地学完这一块内容。(注意笔记中(m,n)=gcd(m,n) )

 

好，进入正题。首先引入三个定义

Definition 1 可乘函数：算术函数f，满足 只要gcd(m,n) =1,就有f(mn)=f(m)f(n)。

没错, 比其他可乘函数宽泛一点，只要在gcd(m,n)=1条件下满足可乘就行。然后我们知道由唯一分解定理，任何正整数n可分解为若干素数的幂方积,所以若为可乘函数，有

![\theta ( n) =\theta \left( p1^{\alpha 1}\right) \theta \left( p2^{\alpha 2}\right) ...\theta \left( pk^{\alpha k}\right)](https://private.codecogs.com/gif.latex?%5Ctheta%20%28%20n%29%20%3D%5Ctheta%20%5Cleft%28%20p1%5E%7B%5Calpha%201%7D%5Cright%29%20%5Ctheta%20%5Cleft%28%20p2%5E%7B%5Calpha%202%7D%5Cright%29%20...%5Ctheta%20%5Cleft%28%20pk%5E%7B%5Calpha%20k%7D%5Cright%29)

Definition 2 ： 代表对n的所有正因子求和，如

​                                                                   ![\sum _{d|4}d^2=1^2+2^2+4^2](https://private.codecogs.com/gif.latex?%5Csum%20_%7Bd%7C4%7Dd%5E2%3D1%5E2&plus;2%5E2&plus;4%5E2)

Definition 3 莫比乌斯函数：

​         ![img](https://img-blog.csdn.net/2018071823001066?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvbWFuZGpha2Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

定义有点奇怪，关于这个函数，之后我们可以看到它的作用, 必须提到的是，可以证明，莫比乌斯函数是可乘函数。

然后是我们的目标----莫比乌斯反演定理：

Theorem 1 莫比乌斯反演定理: F(n)和f(n)为算术函数，若他们满足

​                                                         ![F(n)=\sum_{d|n}f(d)](https://private.codecogs.com/gif.latex?F%28n%29%3D%5Csum_%7Bd%7Cn%7Df%28d%29)

则有

​                                                      ![f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})](https://private.codecogs.com/gif.latex?f%28n%29%3D%5Csum_%7Bd%7Cn%7D%5Cmu%28d%29F%28%5Cfrac%7Bn%7D%7Bd%7D%29)

证明如下：

首先给出一个定理，

![img](https://img-blog.csdn.net/20180718232904406?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvbWFuZGpha2Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

已知![\sum_{d|n}\theta(d)](https://private.codecogs.com/gif.latex?%5Csum_%7Bd%7Cn%7D%5Ctheta%28d%29)为可乘函数。

之后可以得到下一个定理

![img](https://img-blog.csdn.net/2018071823355534?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvbWFuZGpha2Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

定理3证明：

![img](https://img-blog.csdn.net/2018071913540276?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvbWFuZGpha2Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

可以看到，莫比乌斯反演提供了一个F(n)与f(n)的连接，而他们之间的桥梁就是莫比乌斯函数。之后我们会看到具体的例子。这里先给出线性筛莫比乌斯函数的代码：

```c++
int mu[maxn], vis[maxn];
int primes[maxn], cnt;
void get_mu() {
	memset(vis, 0, sizeof(vis));
	memset(mu, 0, sizeof(mu));
	cnt = 0; mu[1] = 1;
	for (int i = 2; i <= maxn; ++i) {
		if (!vis[i]) { primes[cnt++] = i; mu[i] = -1; }
		for (int j = 0; j<cnt&&primes[j] * i <= maxn; ++j) {
			vis[primes[j] * i] = 1;
			if (i%primes[j] == 0)break;
			mu[i*primes[j]] = -mu[i];
		}
	}
}
应用举例：POJ 3904
```

题目给出n和n个正整数，问能找出多少个不同的四元组(a,b,c,d)使得该四元组的最大公因数为1.

分析：

首先要提的是，我们做题目往往用的是莫比乌斯反演的另外一种形式：

![img](https://img-blog.csdn.net/20180719140752243?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvbWFuZGpha2Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

既然要用到莫比乌斯反演，我们首先就要找到合适的F和f。实际上，F和f的关系在于整除。我们可以假设

                          			 F(n)为有多少个四元组满足gcd(a,b,c,d)=n的整数倍
    
                           				f(n)为有多少个四元组满足gcd(a,b,c,d)=n

所以我们的目标就是求f(1), 而实际上可以看出F与f构成了一组莫比乌斯变换对。有了反演公式，我们可以通过求F来求f，而这里面F很好求，要求F（n）我们只要在原数组中数出到能被n整除的数的个数m, 则C（m,4）就是F（n）

而由公式，由此我们可以发现 

直接计算即可。



``` c++ 
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<vector>
#include<stack>
#include<algorithm>
#include<map>
#include<set>
#include<queue>
#include<sstream>
#include<cmath>
#include<iterator>
#include<bitset>
#include<stdio.h>
using namespace std;
#define _for(i,a,b) for(int i=(a);i<(b);++i)
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
typedef long long LL;
const int INF = 1 << 30;
const int MOD = 1e9 + 7;
const int maxn = 10005;

int n, a[maxn], tot[maxn];
int mu[maxn], vis[maxn];
int primes[maxn], cnt;
void get_mu() {
	memset(vis, 0, sizeof(vis));
	memset(mu, 0, sizeof(mu));
	cnt = 0; mu[1] = 1;
	for (int i = 2; i <= maxn; ++i) {
		if (!vis[i]) { primes[cnt++] = i; mu[i] = -1; }
		for (int j = 0; j<cnt&&primes[j] * i <= maxn; ++j) {
			vis[primes[j] * i] = 1;
			if (i%primes[j] == 0)break;
			mu[i*primes[j]] = -mu[i];
		}
	}
}

void get_tot() {
	memset(tot, 0, sizeof(tot));
	for (int i = 0; i<n; ++i) {
		int x = a[i];
		int m = sqrt(x);
		for (int j = 1; j <= m; ++j) {
			if (x%j == 0)tot[j]++, tot[x / j]++;
		}
		if (m*m == x)tot[m]--;
	}
}
LL Cn4(int m) {
	if (m == 0)return 0;
	return 1ll * m*(m - 1)*(m - 2)*(m - 3) / 24;
}
int main()
{
	//freopen("C:\\Users\\admin\\Desktop\\in.txt", "r", stdin);
	//freopen("C:\\Users\\admin\\Desktop\\out.txt", "w", stdout);
	get_mu();
	while (~scanf("%d", &n)) {
		for (int i = 0; i<n; ++i) scanf("%d", &a[i]);
		get_tot();
		LL ans = 0;
		for (int i = 1; i<maxn; ++i) {
			ans += 1ll * mu[i] * Cn4(tot[i]);
		}
		printf("%I64d\n", ans);
	}
	return 0;
}
```

### 扩展欧几里德（求逆元）

```c++
//扩展欧几里德 
int exgcd(int a,int b,long long &x,long long &y)
{
    if(b==0)return x=1,y=0,a;
    int d=exgcd(b,a%b,y,x);//d的值实际上就是gcd(a,b)，如果不需要的话可以不求
    return y-=a/b*x,d;
}
//利用扩展欧几德求逆元
long long inv(long long a,long long m)
{
    long long x,y;
    long long d=exgcd(a,m,x,y);
    return d==1?(x+m)%m:-1;//不互质就没有逆元
}
```

### 博弈问题

0x00 **公平组合游戏ICG**
若一个游戏满足：

**由两名玩家交替行动**

在游戏进程的任意时刻，**可以执行的合法行动与轮到哪名玩家无关**

游戏中的**同一个状态不可能多次抵达**（有向无环），游戏以玩家无法行动为结束，且游戏**一定会在有限步后以非平局结束**

则称该游戏为一个公平组合游戏。

例如 Nim 博弈属于公平组合游戏，而普通的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。

0x01 **有向图游戏**（博弈图）
给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。

任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。 转化为有向图游戏，也称绘制了它的博弈状态图（简称博弈图或游戏图）。

这样，对于组合游戏中的每一次对弈（每一局游戏），我们都可以将其抽象成游戏图中的一条从某一顶点到出度为 0  的点的路径。

组合游戏向图的转化，并不单单只是为了寻找一种对应关系，它可以帮助我们淡化游戏的实际背景**，强化游戏的数学模型，更加突出游戏 的数学本质。**

0x02 先手必胜和先手必败
先手必胜状态 ： 先手行动以后，可以让剩余的状态变成必败状态 留给对手（下一步是对手（后手）的局面）。

先手必败状态 ： 不管怎么操作，都达不到必败状态，换句话说，如果无论怎么行动都只能达到一个先手必胜状态留给对手，那么对手（后手）必胜，先手必败。

简化一下就是：

先手必胜状态：可以走到某一个必败状态

先手必败状态：走不到任何一个必败状态

因为我们当前走到的状态是送给对手的状态h

通常先手是 Alice ，后手是Bob 。

定理：

定理 2.1： **没有后继状态的状态是必败状态**。

定理 2.2： **一个状态是必胜状态当且仅当存在至少一个必败状态为它的后继状态**。

定理 2.3： **一个状态是必败状态当且仅当它的所有后继状态均为必胜状态**。

如果博弈图是一个有向无环图，则通过这三个定理，我们可以在绘出博弈图的情况下用 O(N+M) 的时间（其中 N 为状态种数，M 为边数）得出每个状态是必胜状态还是必败状态。

0x03 必胜点和必败点
必败点(P点) 前一个(previous player)选手将取胜的点称为必败点

必胜点(N点) 下一个(next player)选手将取胜的点称为必胜点

(1) 所有终结点是必败点（P点）

(2) 从任何必胜点（N点）操作，至少有一种方法可以进入必败点（P点）

(3)无论如何操作， 从必败点（P点）都只能进入必胜点（N点）

0x04 有向图的核
给定一张DAG图<V,E>，如果 V  的一个点集 S 满足：

S 是独立集（集合内的点互不相通）

集合V−S 中的点都可以通过一步到达集合 S 中的点（ V−S 指   S 在 V 中的补集）

则称 S 是图 V的一个核。

结论： 核内节点对应 SG 组合游戏的必败态

因为 Alice 当前的棋子在 S 中，由于 S 是独立集，也就意味着 Alice 只能将棋子从 S 移动到 V−S

而 Bob又可以通过一步移动将棋子从 V−S 移动到了 S，这样 Alice 就好像是被支配了一样，被迫把棋子移动到了没有出度的必败节点，Alice 必败，Bob必胜！

 1.巴氏博弈:后手控制和先手的数量之和
       2.威佐夫博弈：有两堆小石子，两个人轮流从某一堆里取石子或从两堆中取相同的石子，每次取石子的个数>=1.
       int  temp = (1.0 + sqrt(5) )/ 2 * (m - n);当差为奇艺局势时，先手必败； 
       3.尼姆博弈：有m堆小石子，两个人轮流从某堆里取石子，每次取石子的个数>=1.最后取光者得胜；
       把每堆物品数全部异或起来，如果得到的值为0，那么先手必败，否则先手必胜。
       4.斐波那契博弈：有一堆物品，两人轮流取物品，先手最少取一个，至多无上限，但不能把物品取完，
       之后每次取的物品数不能超过上一次取的物品数的二倍且至少为一件，取走最后一件物品的人获胜。
        结论是：先手胜当且仅当n不是斐波那契数（n为物品总数）

### 生成函数

实现了桥梁，将多项式、递推式、无穷求和统一。

根据等比数列，建立联系
$$
\frac{1}{1-x} = 1 + x + x^2 + \dots + x^n
$$
通过级数展开，将函数转化为数列
$$
\frac{x}{1-x-x^2} = f(0)x^0+f(1)x^1+\dots + f(n)x_n
$$
核心思想：将数列用一套完善的系统数学形式来表达。

然后利用函数的变换来变换数列

+ 求导
+ 卷积(形成新的数列)

![image-20220325213227823](D:\none_c\ACM\卷积.png)
$$
F(X) = a_0x^0+a_1x^1+a_2x^2+\dots + a_nx^n \\
\frac{1}{1-x}=x^0+x^1+x^2+\dots+x^{n-1}+x^n\\
F(x)*(\frac{1}{1-x}) = a_0 + (a_0+a_1)x^1+(a_0+a_1+a_2)x^2+\dots+(a_0+a_1+\dots+a_n)x^n
$$
得到一个强大的求数列前缀和的公式。

+ *x 相当于右移一项
+ /x 相当于左移一项

牛顿的二项式定理

更多的生成函数
$$
G(X)=e^x = a_0 + a_1x +\frac{a_2x^2}{2!}+\frac{a_3x^3}{3!}+\dots +\frac{a_nx^n}{n!}
$$
dirchlet级数(迪力特雷卷积)
$$
F(S) = a_1 +\frac{a2}{2^s}+\frac{a^3}{3^s}+\dots+\frac{a^n}{n^s}
$$
F(X)*G(X)得到的是带组合数的生成函数

![image-20220325225147659](D:\none_c\ACM\组合数生成.png)

尝试推导卡特兰数。

利用迪离特雷卷积得到(数论的桥梁)

![image-20220325225949610](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20220325225949610.png)
$$
F(S)G(S) = \sum_{n>=1}\sum_{d|n}a_db_{n/d}/n^x
$$
3BlueBrown视频

![image-20220325230832503](D:\none_c\ACM\约数个数.png)

S(S)*S(S);
$$
s(s)^2 =d(1) + \frac{d(2)}{2^s}+\frac{d(3)}{2^s}+\dots+\frac{d(n)}{2^s}
$$


莫比乌斯反演
$$
\frac{1}{s(s)} = \mu(1) + \frac{\mu(2)}{2^s}+\frac{\mu(3)}{2^s}+\dots+\frac{\mu(n)}{2^s}
$$
python brute-force.py

《具体数学》 -- 《generatingfunctionology》

### FFT 快速变换傅里叶

**卷积 (Convolution)(Convolution) ，准确来说是一种通过两个函数 f 和g 生成第三个函数的一种数学算子.**

从广义上定义：

​                                       h(x)=∫∞−∞g(τ)⋅f(x−τ)dτ

在多项式域，那么就把其定义划进多项式，得到：

​                                                                             ![img](file:///C:\Users\二月\AppData\Roaming\Tencent\Users\2211979172\QQ\WinTemp\RichOle\N[VN25XX49A19W$S_AI]L8F.png) 

其中 A(x)和 B(x)均为 n−1次多项式
比较显然的是，在我们合并同类项的情况下，最终卷出来的结果应该有 2n+1 项。

我们知道，原本的多项式是系数表示法，现在我们将其转化为**点值表示法 (dot method)**。即我们可以把多项式 F(x)转化为多项式函数 f(x) ，那么这个 n 阶函数就可以由 n+1 个点唯一确定。即给定         

![img](file:///C:\Users\二月\AppData\Roaming\Tencent\Users\2211979172\QQ\WinTemp\RichOle\P}X1}EMQG2ZQ6KA$}_9`K[J.png)

对于一个多项式乘法问题，当给出系数表示法的时候， O(n^2)的复杂度有时候并不足够优越，而FFT就是一个能使多项式乘法做到O（nlogn）的一个算法，具体的原理其实非常清晰:

两个多项式的系数表示法求值，O(nlogn)
两个多项式的点值表示法点值乘法，O(n)
两个多项式乘积的点值表示法插值，O(nlogn)
两个多项式乘积的系数表示法
**暴力算法（O(n^3)）**
要先做题，必先暴力
首先是求值，加入你现在随便找了n个互不相同的x，带入其中，是什么复杂度呢**O(n^2)**的然后是插值,   有一个非常妙的方法，假设所有的a都是未知数，那么这个问题就变成了经典的高斯消元问题，复杂度O(n^3)
不好意思，这两个操作的复杂度都光荣的在 O(n^2)以上，使得当前这个算法的总复杂度为O(n^3)，比文章开始的那个O(n^2)都要差，不要灰心，既然复杂度不优，那就循序渐进的优化

**离散傅里叶变换**

点值表示法有一个很好的特性，就是那个代入的x可以自己选择
离散傅里叶变换的思路是将n个x的值取n个单位根（模长为一的复数）

```chinese
复数（这是一个知识拓展框）
 这个数，在实数范围内是不存在的，所以拓展出复数这一概念，设i = − 1 
 ，复数就是能够被表示为z = x + y ∗ i z=x+y*iz=x+y∗i的数。所以对一个复数，可以用有序数对(x,y)表示，在坐标轴上有对应的点，而这个复数就是从(0,0)到(x,y)的一条有向线段（只会向量的同学可以把它看成向量），而这个复数的模长就等于(0,0)到(x,y)的距离
由于复数是数，所以也有各种运算
加法：(a+bi)+(c+di)=(a+c)+(b+d)i
减法：(a+bi)-(c+di)=(a-c)+(b-d)i
乘法：(a+bi)*(c+di)=(ac-bd)+(ad+bc)i
当然，C++有专门的complex变量可以声明，但是

不推荐使用！！！
为什么呢？因为FFT本身就有一定的常数，如果再用系统complex常数会更大，所以推荐自己手写struct
```



**二进制常数优化后的FFT**

```C++
#include<cstdio>
#include<cctype>
#include<cmath>
namespace fast_IO
{
	const int IN_LEN=10000000,OUT_LEN=10000000;
	char ibuf[IN_LEN],obuf[OUT_LEN],*ih=ibuf+IN_LEN,*oh=obuf,*lastin=ibuf+IN_LEN,*lastout=obuf+OUT_LEN-1;
	inline char getchar_(){return (ih==lastin)&&(lastin=(ih=ibuf)+fread(ibuf,1,IN_LEN,stdin),ih==lastin)?EOF:*ih++;}
	inline void putchar_(const char x){if(oh==lastout)fwrite(obuf,1,oh-obuf,stdout),oh=obuf;*oh++=x;}
	inline void flush(){fwrite(obuf,1,oh-obuf,stdout);}
}
using namespace fast_IO;
#define getchar() getchar_()
#define putchar(x) putchar_((x))
typedef long long LL;
#define rg register
#define complex Complex //防止和库函数冲突
template <typename T> inline void swap(T&a,T&b){T c=a;a=b;b=c;}
template <typename T> inline void read(T&x)
{
    char cu=getchar();x=0;bool fla=0;
    while(!isdigit(cu)){if(cu=='-')fla=1;cu=getchar();}
    while(isdigit(cu))x=x*10+cu-'0',cu=getchar();
    if(fla)x=-x;  
}
template <typename T> void printe(const T x)
{
    if(x>=10)printe(x/10);
    putchar(x%10+'0');
}
template <typename T> inline void print(const T x)
{
    if(x<0)putchar('-'),printe(-x);
    else printe(x);
}
const int maxn=2097153;const double PI=acos(-1.0);
int n,m;
struct complex
{
	double x,y;
	inline complex operator +(const complex b)const{return (complex){x+b.x,y+b.y};}
	inline complex operator -(const complex b)const{return (complex){x-b.x,y-b.y};} 
	inline complex operator *(const complex b)const{return (complex){x*b.x-y*b.y,x*b.y+y*b.x};}
}a[maxn],b[maxn];
int lenth=1,Reverse[maxn];
inline void init(const int x)
{
	rg int tim=0;
	while(lenth<=x)lenth<<=1,tim++;
	for(rg int i=0;i<lenth;i++)Reverse[i]=(Reverse[i>>1]>>1)|((i&1)<<(tim-1));
}
inline void FFT(complex*A,const int fla)
{
	for(rg int i=0;i<lenth;i++)if(i<Reverse[i])swap(A[i],A[Reverse[i]]);
	for(rg int i=1;i<lenth;i<<=1)
	{
		const complex w=(complex){cos(PI/i),fla*sin(PI/i)};
		for(rg int j=0;j<lenth;j+=(i<<1))
		{
			complex kk=(complex){1,0};
			for(rg int k=0;k<i;k++,kk=kk*w)
			{
				const complex x=A[j+k],y=A[j+k+i]*kk;
				A[j+k]=x+y;
				A[j+k+i]=x-y;
			}
		}
	}
}
int main()
{
	read(n),read(m);
	init(n+m);
	for(rg int i=0;i<=n;i++)read(a[i].x);//读入多项式A（n+1）项
	for(rg int i=0;i<=m;i++)read(b[i].x);//读入多项式B（m+1）项
	FFT(a,1),FFT(b,1);//对多项式求点值
	for(rg int i=0;i<lenth;i++)a[i]=a[i]*b[i];//点值相乘
	FFT(a,-1);//对多项式求插值
	for(rg int i=0;i<=n+m;i++)print((int)(a[i].x/lenth+0.5)),putchar(' ');//lenth看上面，就分治之类的
	return flush(),0;
}
/*
 1 2
 1 2
 1 2 1
 1 4 5 2
 */

```

### 高斯消元法

#### 高斯消元解线性方程组

步骤：

- 增广矩阵行初等行变换为行最简形；
- 还原线性方程组；
- 求解第一个变量；
- 补充自由未知量；
- 列表示方程组通解。

```c++
const int N = 507, mod = 1e9 + 7;
const double eps = 1e-6;
int n, m;
double a[N][N];
int guass()
{
    int c;//当前最左边的一列
    int r;//当前最上面的一行
    for(c = 1, r = 1; c <= n; ++ c){
        int t = r;
        for(int i = r + 1; i <= n; ++ i){
            if(fabs(a[i][c]) > fabs(a[t][c]))
               t = i;
        }
        if(fabs(a[t][c]) < eps)//等于0就下一个
            continue;
        //换到第一行（最上面的一行）
        for(int i = c; i <= n + 1; ++ i)
            swap(a[t][i], a[r][i]);
        //把该行第一个数变成 1（该行每一列都/=第c列的值）
        for(int i = n + 1; i >= c; -- i)
            a[r][i] /= a[r][c];
		//中间所有列（所有项）全部消掉
        for(int i = r + 1; i <= n; ++ i)
            if(fabs(a[i][c]) > eps)
                for(int j = n + 1; j >= c; -- j)
                    a[i][j] -= a[r][j] * a[i][c];
        r ++ ;
    }
    if(r <= n){
        for(int i = r; i <= n; ++ i)
            if(fabs(a[i][n + 1]) > eps)//非零，无解
            	return 2;
        return 1;//无穷多组解
    }//回代
    //行最简形矩阵
    for(int i = n; i >= 1; -- i)
        for(int j = i + 1; j <= n + 1; ++ j)
            a[i][n + 1] -= a[j][n + 1] * a[i][j];    
 /* 只要保留第i行第i列的系数即可,所以从第i+1行开始一直消到第n行,
    因为只要结果,所以可以只消第i行第n+1列的数(b);就是上面消掉所有列的简化版，少了一个for循环*/  
    return 0;
}
int main()
{
    cin >> n;
    for(int i = 1; i <= n; ++ i)
        for(int j = 1; j <= n + 1; ++ j)
            cin >> a[i][j];
    int t = guass();
    if(t == 0){
        for(int i = 1; i <= n; ++ i)
            printf("%.2f\n", a[i][n + 1]);
    }

    else if(t == 1)puts("Infinite group solutions");//无穷组解
    else puts("No solution");//无解
    return 0;
}


```

#### 高斯-约旦消元法

约旦消元法的精度更好、代码更简单，没有回带的过程。

约旦消元法大致思路如下：

- 1.选择一个**尚未被选过**的未知数作为主元，选择一个包含这个主元的方程。
- 2.将**这个方程**主元的系数化为1。
- 3.通过加减消元，消掉**其它所有方程中**的这个未知数。
- 4.重复以上步骤，直到把每一行都变成**只有一项有系数**。

我们用矩阵表示每一项系数以及结果.

有被出题人卡的风险。

```c++
const int N = 5007;
const double eps = 1e-6;//
int n, m;
double a[N][N];

int guass() {
    for(int i = 1; i <= n; ++ i) {//枚举列
        int maxx = i;
        //1.找
        for(int j = i + 1; j <= n; ++ j)
//第i列以前的未知量除了第i一行的所有行都已经都已经消成0了，不能再动了
            if(fabs(a[j][i]) > fabs(a[maxx][i]))
                maxx = j;
        //2.换
        for(int j = 1; j <= n + 1; ++ j)//找到的最大一行跟第i行换
            swap(a[i][j], a[maxx][j]);
        if(fabs(a[i][i]) < eps) return -1;
        //3.减
        for(int j = 1; j <= n; ++ j)
//把该未知量除第i行以外全部减成0（普通的高斯是第i行以下减为0，但是需要回代）
            if(j != i) {
                double tmp = a[j][i] / a[i][i];
                for(int k = i + 1; k <= n +1; ++ k) //只需要减第i列右边就行了，因为左边全为0
                    a[j][k] -= a[i][k] * tmp;
            }                               //高斯 - 约旦 消元法
    }                                       //最后会得到这样的矩阵
    for(int i = 1; i <= n; ++ i)            //    k1*a=e1
        a[i][n + 1] /= a[i][i];             //    k2*b=e2
    //所以最后要除以该项的系数     <--        //    k3*c=e3
    return 1;                               //    k4*d=e4
}

int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; ++ i)
        for(int j = 1; j <= n + 1; ++ j)
            scanf("%lf", &a[i][j]);
    int ans = guass();
    if(ans == -1) puts("No Solution");
    else for(int i = 1; i <= n; ++ i)
            printf("%.2f\n", a[i][n + 1]);
    return 0;
}

```

#### 高斯消元解亦或线性方程组

```c++
输入一个包含n个方程n个未知数的异或线性方程组。

方程组中的系数和常数为0或1，每个未知数的取值也为0或1。

求解这个方程组。

异或线性方程组示例如下：
M[1][1]x[1] ^ M[1][2]x[2] ^ … ^ M[1][n]x[n] = B[1]
M[2][1]x[1] ^ M[2][2]x[2] ^ … ^ M[2][n]x[n] = B[2]
…
M[n][1]x[1] ^ M[n][2]x[2] ^ … ^ M[n][n]x[n] = B[n]

```

```c++
const int N = 107, M = 500007, INF = 0x3f3f3f3f;
int n, m;
bitset<120> a[N];
int guass(int n, int m)//n row n 行 m col m 列
{
    int row = 0, col = 0, maxx;
    for(; col < m; ++ col) {
        for(maxx = row; maxx < n; ++ maxx)
            if(a[maxx][col])
                break;
        if(maxx == n) continue;
                
        if(a[maxx][col] == 0) continue;
        
        swap(a[maxx], a[row]);
        
        for(int i = row + 1; i < n; ++ i) 
            if(a[i][col]) //如果这一列有数的话那一行全部消掉
                a[i] = a[i] ^ a[row];
                //for(int j = n; j >= col; -- j)//col前面都是0，无所谓
                    //a[i][j] = a[i][j] ^ a[row][j];
        row ++ ;
    }
    
    if(row < n) {
        for(int i = row; i < n; ++ i) 
            if(a[i][m])//矛盾，出现非零的常数项等于0，说明无解
                return 2;
        return 1;//有无穷多组解
    }
    //行最简形矩阵，第i行第i列的表示的未知量x_i的一个解
    for(int i = n - 1; i >= 0; -- i) {//第i行，第i行第i列
        for(int j = i + 1; j < m; ++ j)//第j列，右边所有列都要消
                a[i][m] = a[i][m] ^ (a[j][m] * a[i][j]);
    }
    return 0;
}

int x;

itn main()
{
    scanf("%d", &n);
    m = n;
    for(int i = 0; i < n; ++ i) 
        for(int j = 0; j < m + 1; ++ j) //+1是因为多了一个常数矩阵（也即是答案）
            scanf("%d", &x), a[i][j] = x;
    int res = guass(n, m);
    if(res == 0) {
        for(int i = 0; i < n; ++ i) 
            x = a[i][m], printf("%d\n", x);
            
    }
    else if(res == 2) puts("No solution");
    else puts("Multiple sets of solutions");
    return 0;
}
```

### 拉格朗日插值法

当点值法表示的点为连续时的O(n)算法。

```c++
#include <cstdio>
#include <cmath>
#include <cstring>
#include <string>
#include <algorithm>
#include <queue>
#include <map>
#include <set>
#include <vector>
#include <iostream>
using namespace std; 
__int64 mod=1000000000+7;
__int64 pow_m(__int64 a,__int64 b)
{
	__int64 ans=1;
	__int64 tmp=a;
	while(b)
	{
		if (b&1)
			ans=ans*tmp%mod;
		tmp=tmp*tmp%mod;
		b>>=1;
	}
	return ans;
}
__int64 y[1000000+60];		//预处理 前k+2的sum
__int64 jie[1000000+60];	//阶乘预处理
int n,k;
__int64 get_jie(int x)		//得到x位的分母
{
	if (x==1||x==k+2) return jie[k+1];
	else
		return jie[x-1]*jie[k+2-x]%mod;
}
int main()
{
	
	cin>>n>>k;
	int i;
	for (i=1;i<=k+2;i++)			//预处理sum_of  i^k
		y[i]=(y[i-1]+pow_m(i,k))%mod; 
	
	if (n<=k+2)
	{	
		printf("%I64d\n",y[n]); return 0;
	}
	jie[0]=1;
	for (i=1;i<=k+2;i++)		//预处理阶乘
		jie[i]=jie[i-1]*i%mod ;
	
	__int64 tol=1;
	for (i=1;i<=k+2;i++)		//分子部分的总乘积	
		tol=tol*(n-i)%mod;
	__int64 ans=0;
	__int64 tmp;	
	for (i=1;i<=k+2;i++)		//根据拉格朗日插值，有k+2项 
	{
		tmp=  tol*pow_m(n-i,mod-2)%mod ;			//分子= 总乘积tol/(n-i)
		tmp= pow_m(get_jie(i),mod-2)%mod*tmp%mod;	//分母为get_jie(i)部分
		int one;
		if ((k+2-i)%2)		//判断正负
			one=-1;
		else 
			one=1; 
		ans= (  ans+ one*tmp*y[i]   )%mod;		//记得乘上Y【i】  
	}
	
	while(ans<0) 
		ans+=mod; 
	printf("%I64d\n",ans%mod); 
	
	
	
	return 0;
	
} 
```

### NTT求原根

使用NTT需要保证模数mod 为质数。

　　通过以下代码求得一个模数的原根 ， 常见的质数的原根 998244353 -> 3  1e9+7 -> 5

```c++
#include<bits/stdc++.h>
#define ll long long
#define IL inline
#define RG register
using namespace std;
 
ll prm[1000],tot,N,root;
 
ll Power(ll bs,ll js,ll MOD){
    ll S = 1,T = bs;
    while(js){
        if(js&1)S = S*T%MOD;
        T = T*T%MOD; 
        js >>= 1; 
    } return S;
}
 
IL ll GetRoot(RG ll n){
    RG ll tmp = n - 1 , tot = 0;
    for(RG ll i = 2; i <= sqrt(tmp); i ++){
        if(tmp%i==0){
            prm[++tot] = i;
            while(tmp%i==0)tmp /= i;
        }
    }
    if(tmp != 1)prm[++tot] = tmp;            //质因数分解
    for(RG ll g = 2; g <= n-1; g ++){
        bool flag = 1;
        for(RG int i = 1; i <= tot; i ++){     //检测是否符合条件
            if(Power(g,(n-1)/prm[i],n) == 1)
                { flag = 0; break; } 
        }
        if(flag)return g;
    }return 0;                        //无解 
}
 
int main(){
    cin >> N;
    root = GetRoot(N);
    cout<<root<<endl;
    return 0;
}
```

### NTT



```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mul(x,y) (1ll*x*y>=mod?1ll*x*y%mod:1ll*x*y)
#define minus(x,y) (1ll*x-y<0?1ll*x-y+mod:1ll*x-y)
#define plus(x,y) (1ll*x+y>=mod?1ll*x+y-mod:1ll*x+y)
#define ck(x) (x>=mod?x-mod:x)
const int N = 3000007;
const ll mod = 998244353;
typedef vector<ll> poly;
const int G = 3;
ll qpow(ll a, ll b)
{
	ll base = a, ans = 1;
	while (b)
	{
		if (b % 2)ans = ans * base%mod;
		base = base * base%mod;
		b >>= 1;
	}
	return ans;
}
const ll inv_G = qpow(G, mod - 2);
ll RR[N], deer[2][20][N], inv[N];
void init(const ll t) {//预处理出来NTT里需要的w和wn，砍掉了一个log的时间
	for (int p = 1; p <= t; ++p) {
		int buf1 = qpow(G, (mod - 1) / (1 << p));
		int buf0 = qpow(inv_G, (mod - 1) / (1 << p));
		deer[0][p][0] = deer[1][p][0] = 1;
		for (int i = 1; i < (1 << p); ++i) {
			deer[0][p][i] = 1ll * deer[0][p][i - 1] * buf0 % mod;//逆
			deer[1][p][i] = 1ll * deer[1][p][i - 1] * buf1 % mod;
		}
	}
	inv[1] = 1;
	for (int i = 2; i <= (1 << t); ++i)
		inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod;
}

int NTT_init(int n) {//快速数论变换预处理
	int limit = 1, L = 0;
	while (limit <= n) limit <<= 1, L++;
	for (int i = 0; i < limit; ++i)
		RR[i] = (RR[i >> 1] >> 1) | ((i & 1) << (L - 1));
	return limit;
}

void NTT(poly &A, int type, int limit) {//快速数论变换
	A.resize(limit);
	for (int i = 0; i < limit; ++i)
		if (i < RR[i])
			swap(A[i], A[RR[i]]);
	for (int mid = 2, j = 1; mid <= limit; mid <<= 1, ++j) {
		int len = mid >> 1;
		for (int pos = 0; pos < limit; pos += mid) {
			ll *wn = deer[type][j];
			for (int i = pos; i < pos + len; ++i, ++wn) {
				int tmp = 1ll * (*wn) * A[i + len] % mod;
				A[i + len] = ck(A[i] - tmp + mod);
				A[i] = ck(A[i] + tmp);
			}
		}
	}
	if (type == 0) {
		for (int i = 0; i < limit; ++i)
			A[i] = 1ll * A[i] * inv[limit] % mod;
	}
}

poly poly_mul(poly A, poly B) {//多项式乘法
	int deg = A.size() + B.size() - 1;
	int limit = NTT_init(deg);
	poly C(limit);
	NTT(A, 1, limit);
	NTT(B, 1, limit);
	for (int i = 0; i < limit; ++i)
		C[i] = 1ll * A[i] * B[i] % mod;
	NTT(C, 0, limit);
	C.resize(deg);
	return C;
}

poly poly_inv(poly &f, int deg) {//多项式求逆
	if (deg == 1)
		return poly(1, qpow(f[0], mod - 2));

	poly A(f.begin(), f.begin() + deg);
	poly B = poly_inv(f, (deg + 1) >> 1);
	int limit = NTT_init(deg << 1);
	NTT(A, 1, limit), NTT(B, 1, limit);
	for (int i = 0; i < limit; ++i)
		A[i] = B[i] * (2 - 1ll * A[i] * B[i] % mod + mod) % mod;
	NTT(A, 0, limit);
	A.resize(deg);
	return A;
}

poly poly_dev(poly f) {//多项式求导
	int n = f.size();
	for (int i = 1; i < n; ++i) f[i - 1] = 1ll * f[i] * i % mod;
	return f.resize(n - 1), f;//f[0] = 0，这里直接扔了,从1开始
}

poly poly_idev(poly f) {//多项式求积分
	int n = f.size();
	for (int i = n - 1; i; --i) f[i] = 1ll * f[i - 1] * inv[i] % mod;
	return f[0] = 0, f;
}

poly poly_ln(poly f, int deg) {//多项式求对数
	poly A = poly_idev(poly_mul(poly_dev(f), poly_inv(f, deg)));
	return A.resize(deg), A;
}

poly poly_exp(poly &f, int deg) {//多项式求指数
	if (deg == 1)
		return poly(1, 1);

	poly B = poly_exp(f, (deg + 1) >> 1);
	B.resize(deg);
	poly lnB = poly_ln(B, deg);
	for (int i = 0; i < deg; ++i)
		lnB[i] = ck(f[i] - lnB[i] + mod);

	int limit = NTT_init(deg << 1);//n -> n^2
	NTT(B, 1, limit), NTT(lnB, 1, limit);
	for (int i = 0; i < limit; ++i)
		B[i] = 1ll * B[i] * (1 + lnB[i]) % mod;
	NTT(B, 0, limit);
	B.resize(deg);
	return B;
}

poly poly_sqrt(poly &f, int deg) {//多项式开方
	if (deg == 1) return poly(1, 1);
	poly A(f.begin(), f.begin() + deg);
	poly B = poly_sqrt(f, (deg + 1) >> 1);
	poly IB = poly_inv(B, deg);
	int limit = NTT_init(deg << 1);
	NTT(A, 1, limit), NTT(IB, 1, limit);
	for (int i = 0; i < limit; ++i)
		A[i] = 1ll * A[i] * IB[i] % mod;
	NTT(A, 0, limit);
	for (int i = 0; i < deg; ++i)
		A[i] = 1ll * (A[i] + B[i]) * inv[2] % mod;
	A.resize(deg);
	return A;
}

poly poly_pow(poly f, int k) {//多项式快速幂
	f = poly_ln(f, f.size());
	for (auto &x : f) x = 1ll * x * k % mod;
	return poly_exp(f, f.size());
}





poly poly_arcsin(poly f, int deg) {
	poly A(f.size()), B(f.size()), C(f.size());
	A = poly_dev(f);
	B = poly_mul(f, f);
	for (int i = 0; i < deg; ++i)
		B[i] = minus(mod, B[i]);
	B[0] = plus(B[0], 1);
	C = poly_sqrt(B, deg);
	C = poly_inv(C, deg);
	C = poly_mul(A, C);
	C = poly_idev(C);
	return C;
}

poly poly_arctan(poly f, int deg) {
	poly A(f.size()), B(f.size()), C(f.size());
	A = poly_dev(f);
	B = poly_mul(f, f);
	B[0] = plus(B[0], 1);
	C = poly_inv(B, deg);
	C = poly_mul(A, C);
	C = poly_idev(C);
	return C;
}
int main()
{
	init(18);
	int n, m;
	cin >> n >> m;
	vector<ll>v(n + 1);
	vector<ll>A(n + 1);
	for (int i = 1; i <= m; i++)
	{
		ll x, y;
		cin >> x >> y;
		if(x<=n)v[x]++;
		if (y && 1ll * x*(y + 1) <= n)
		{
			v[x*(y + 1)]--;
		}
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = i; j <= n; j += i)
		{
			A[j] = (A[j] + 1ll * v[i] * qpow(j / i, mod - 2) % mod) % mod;
		}
	}
	poly B = poly_exp(A, n + 1);
	for (int i = 1; i <= n; i++)
	{
		cout << (B[i] + mod) % mod << '\n';
	}
}
```





## 图论

### 树的性质

#### 树的直径

树上最远两点（叶子结点）的距离。

求法：从任意一点dfs(bfs)找到最长的点new,从new出发再dfs(bfs)再找最远的点last，new到last即为树的直径。

延伸：树上任意点能到的最远点，一定是树的直径的某个端点。

y总的有趣解法:自下而上看到达该点的最长路和次长路，两者相加即为最长路，缺点不好找这条路的左右端点。

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
#define ll long long
vector<pair<int,ll> >a[maxn];
ll dis=-1e9;
ll dfs(int s, int fa)
{
	ll d1=0,d2=0,d=0;
	for(int i=0;i<a[s].size();i++)
	{
		int to=a[s][i].first;ll w=a[s][i].second;
		if(to==fa)continue;
		ll d=dfs(to,s);
		if(d+w>=d1)d2=d1,d1=d+w;
		else if(d+w>=d2)d2=d+w;
	}
	dis=max(d1+d2,dis);
	return d1;
}
int main()
{
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=1;i<n;i++)
	{
		int u,v;ll w;
		cin>>u>>v>>w;
		a[u].push_back({v,w});
		a[v].push_back({u,w});
	}
	dfs(1,0);
	cout<<dis<<endl;
	return 0;
}
```

#### 树的中心

找到树上的一个点满足：该点到其他点的最远距离最小。

```
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
#define ll long long
vector<pair<int, ll>> e[maxn];
ll d1[maxn], d2[maxn], up[maxn], prm1[maxn], prm2[maxn];
ll dfs(int s, int fa)
{
    for (int i = 0; i < e[s].size(); i++)
    {
        int to = e[s][i].first;
        ll w = e[s][i].second;
        if (to == fa)
            continue;
        ll d = dfs(to, s);
        if (d + w >= d1[s])
            d2[s] = d1[s], d1[s] = d + w, prm2[s] = prm1[s], prm1[s] = to;
        else if (d + w >= d2[s])
            d2[s] = d + w, prm2[s] = to;
    }
    return d1[s];
}

void dfs2(int s, int fa)
{
    for (int i = 0; i < e[s].size(); i++)
    {
        int to = e[s][i].first;
        ll w = e[s][i].second;
        if (to == fa)
            continue;
        if (prm1[s] != to)
            up[to] = max(up[s], d1[s])+w;//如果s中的最長路包含to，那麼為d2+w,否則答案為d1+w;
        else
            up[to] = max(up[s], d2[s])+w;
        dfs2(to, s);
    }
}
int main()
{
    ios::sync_with_stdio(false);
    //freopen("1.txt","r",stdin);
    int n;
    cin >> n;
    for (int i = 1; i < n; i++)
    {
        int u, v;
        ll w;
        cin >> u >> v >> w;
        e[u].push_back({v, w});
        e[v].push_back({u, w});
    }
    dfs(1, -1);
    //for(int i=1;i<=n;i++)cout<<d1[i]<<endl;
    dfs2(1, -1);
    ll res = 1e9 + 1;
    for (int i = 1; i <= n; i++)
        res = min(res, max(up[i], d1[i]));
    cout << res << endl;
    return 0;
}
/*
5 
2 1 1 
3 2 1 
4 3 1 
5 1 1

2
*/
```



1. 

### LCA

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn = 4e4 + 5;
const ll mod = 998244353;
//新年快乐！
int fa[maxn][60],dep[maxn],root;//dep表示结点深度，fa是倍增表
vector<int>e[maxn];
void lca_d(int s,int father)
{
	dep[s] = dep[father] + 1;
	fa[s][0] = father;
	for (int i = 1; i <= 30; i++)fa[s][i] = fa[fa[s][i - 1]][i - 1];
	for(int i=0;i<e[s].size();i++)
	{
		int to = e[s][i];
		if (to == father)continue;
		lca_d(to, s);
	}
}
int lca_q(int x,int y)
{
	if (dep[x] < dep[y])swap(x, y);
	int num = dep[x] - dep[y];
	for(int i=30;i>=0;i--)
	{
		if (num >= (1 << i))num -= (1 << i), x = fa[x][i];
	}
	if (x == y)return x;
	for(int i=30;i>=0;i--)
	{
		if (fa[x][i] != 0&&fa[y][i]!=0&&fa[x][i]!=fa[y][i])x = fa[x][i],y=fa[y][i];
	}
	return fa[x][0];
	
}
void solve()
{
	int n, q;
	cin >> n;
	for(int i=1;i<=n;i++)
	{
		int u, v;
		cin >> u >> v;
		if (v == -1)root = u;
		else 
		{
			e[u].push_back(v); 
			e[v].push_back(u);
		}
	}
	lca_d(root, 0);
	cin >> q;
	for(int i=1;i<=q;i++)
	{
		int x, y;
		cin >> x >> y;
		int lca= lca_q(x, y);
		if (lca == x)cout << 1 << endl;
		else if (lca == y)cout << 2 << endl;
		else cout << 0 << endl;
	}
}
int main()
{
	ios::sync_with_stdio(false);
	int t = 1;
	while (t--)solve();
	return 0;
}
```



### 最小生成树

1.prim法

时间o(n2);?

```c++
/*
*邮箱：unique_powerhouse@qq.com
*blog:https://me.csdn.net/hzf0701
*注：文章若有任何问题请私信我或评论区留言，谢谢支持。
*
*/
#include<bits/stdc++.h>	//POJ不支持

#define rep(i,a,n) for (int i=a;i<=n;i++)//i为循环变量，a为初始值，n为界限值，递增
#define per(i,a,n) for (int i=a;i>=n;i--)//i为循环变量， a为初始值，n为界限值，递减。
#define pb push_back
#define IOS ios::sync_with_stdio(false);cin.tie(0); cout.tie(0)
#define fi first
#define se second
#define mp make_pair

using namespace std;

const int inf = 0x3f3f3f3f;//无穷大
const int maxn = 1e3;//最大值。
typedef long long ll;
typedef long double ld;
typedef pair<ll, ll>  pll;
typedef pair<int, int> pii;
//*******************************分割线，以上为自定义代码模板***************************************//

int n,m;//图的大小和边数。
int graph[maxn][maxn];//图
int lowcost[maxn],closest[maxn];//lowcost[i]表示i到距离集合最近的距离，closest[i]表示i与之相连边的顶点序号。
int sum;//计算最小生成树的权值总和。
void Prim(int s){
	//初始化操作，获取基本信息。
	for(int i=1;i<=n;i++){
		if(i==s)
			lowcost[i]=0;
		else
			lowcost[i]=graph[s][i];
		closest[i]=s;
	}
	int minn,pos;//距离集合最近的边，pos代表该点的终边下标。
	sum=0;
	for(int i=1;i<=n;i++){
		minn=inf;
		for(int j=1;j<=n;j++){
			//找出距离点集合最近的边。
			if(lowcost[j]!=0&&lowcost[j]<minn){
				minn=lowcost[j];
				pos=j;
			}
		}
		if(minn==inf)break;//说明没有找到。
		sum+=minn;//计算最小生成树的权值之和。
		lowcost[pos]=0;//加入点集合。
		for(int j=1;j<=n;j++){
			//由于点集合中加入了新的点，我们要去更新。
			if(lowcost[j]!=0&&graph[pos][j]<lowcost[j]){
				lowcost[j]=graph[pos][j];
				closest[j]=pos;//改变与顶点j相连的顶点序号。
			}
		}
	}
	cout<<sum<<endl;//closest数组就是我们要的最小生成树。它代表的就是边。
}
void print(int s){
	//打印最小生成树。
	int temp;
	for(int i=1;i<=n;i++){
		//等于s自然不算，故除去这个为n-1条边。
		if(i!=s){
			temp=closest[i];
			cout<<temp<<"->"<<i<<"边权值为："<<graph[temp][i]<<endl;
		}
	}
}
int main(){
	//freopen("in.txt", "r", stdin);//提交的时候要注释掉
	IOS;
	while(cin>>n>>m){
		memset(graph,inf,sizeof(graph));//初始化。
		int u,v,w;//临时变量。
		for(int i=1;i<=m;i++){
			cin>>u>>v>>w;
			//视情况而论，我这里以无向图为例。
			graph[u][v]=graph[v][u]=w;
		}
		//任取根结点，我这里默认取1.
		Prim(1);
		print(1);//打印最小生成树。
	}
	return 0;
}




```



### 最短路

Dijkstra、Bellman_Ford、SPFA、Floyd

 Dijkstra：适用于权值为非负的图的（单源最短路径），用斐波那契堆的复杂度O(E+VlgV)，其实就是spfa加优先队列，保证每次出队的一定是全局最优解；
       BellmanFord：适用于权值有负值的图的单源最短路径，并且能够检测负圈，复杂度O(VE)
       SPFA：适用于权值有负值，且没有负圈的图的单源最短路径，论文中的复杂度O(kE)，k为每个节点进入Queue的次数，
       且k一般<=2，但此处的复杂度证明是有问题的，其实SPFA的最坏情况应该是O(VE).
       Floyd：每对节点之间的最短路径
       正权图使用dijkstra算法,负权图使用SPFA算法
   SPFA算法：
       时间复杂度
      核心思想：利用队列，判断dp[当前点]和dp[上一个结点]+w的大小，如果更新了，就让其入队，visit[]看其是否在队列中，在就不用入队了。
       判断有无负环：如果某个点进入队列的次数超过V次则存在负环（SPFA无法处理带负环的图）。
       在没有负环、单纯求最短路径，不建议使用SPFA算法，而是用Dijkstra算法。
   dijkstra算法：利用优先队列来保证每次更新最优，即出队之后便不用在出队
   Bellman-ford算法：适用于单源最短路径，时间复杂度是O(VE)
       dist[]：从original到其他顶点的最短路径长初始为无穷大，自然地，从original到original的距离为0。代表从original到各个顶点的最短路径长度。
       pre[]：代表该点在最短路径中的上一个顶点。
       1.初始化：除了起点的距离为0外（dist[original] = 0），其他均设为无穷大。
       2.迭代求解：循环对边集合E的每条边进行松弛操作，使得顶点集合V中的每个顶点v的距离长逐步逼近最终等于其最短距离长；
       3.验证是否负权环：再对每条边进行松弛操作。如果还能有一条边能进行松弛，那么就返回False，否则算法返回True
        通过对每一条边松弛，迭代n次，时间复杂度O(VE)，看起来有很大的优化空间，可以利用队列优化，优化之后就是赤裸裸的spafa；
    floyd算法：

0x7fffffff:int 的最大值

#### spfa:

```c++
#include<iostream>
#include<string.h>
#include<stdio.h>
#include<queue>
#include<cmath>
#define ll long long 
#define scf(x)  scanf("%lld",&x)
using namespace std;
const int maxn=1e4+4;
const int maxm=5e5+5;
ll head[maxn],dp[maxn];
bool ex[maxn],dd[maxn];//前者是是否在对列中，后者是是否达到过 
struct dt
{
	ll v;
	ll w;
	ll next;
}p[maxm];
void zt(ll i,ll u,ll v,ll w){
	p[i].w=w;
	p[i].v=v;
	p[i].next=head[u];
	head[u]=i;
}
void spfa(ll s)
{
	queue<ll>q;
	q.push(s);
	ex[s]=true;
	dd[s]=true;
	while(q.empty()==0)
	{
		ll n;
		dp[s]=0;
		n=q.front();
		q.pop();
		ex[n]=false;
		for(ll i=head[n];i;i=p[i].next)
		{
			if(dp[p[i].v]>dp[n]+p[i].w)
			{
				dp[p[i].v]=dp[n]+p[i].w;
				if(ex[p[i].v]==false)ex[p[i].v]=true,q.push(p[i].v);
			}
		    dd[p[i].v]=true;
		}	
	}
}
int main()
{
	memset(head,0,sizeof(head));
	memset(ex,false,sizeof(ex));
	memset(dp,0x3f,sizeof(dp));
	memset(dd,false,sizeof(dd));
	ll n,m,k,u,v,w,s;
	cin>>n>>m>>s;
	for(ll i=1;i<=m;i++)
	{
		scf(u);scf(v);scf(w);
		zt(i,u,v,w);
	}
	spfa(s);
	for(int i=1;i<=n;i++)
	{
		if(dd[i])printf("%lld ",dp[i]);
		else printf("2147483647 ");
	}
/*	int sum=1;
	for(int i=1;i<=31;i++)sum*=2;
	sum-=1;
	printf("%d",sum);*/
	return 0;
}
```

#### dikjstra

**朴素版：**

朴素版的djstra的时间复杂度是个稳定的(n^2);

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
#define ll long long 
const int maxn=1e3+3;
const int maxm=1e5+5;
const ll inf=0x7f7f7f;
ll dis[maxn],n,vis[maxn],S;
ll t[maxn][maxn];//利用邻接矩阵存图
void dijkstra()
{
	memset(vis,0,sizeof(vis));//初始化标记数组
	for(int i=1;i<=n;i++)
	{
		dis[i]=t[S][i];//更新从起点能到达的点的距离信息
	}	
	dis[S]=0;//起点到起点距离为0;
	vis[S]=1;int to;
	for(int i=1;i<=n;i++)//找到最小的点作为新的起点
	{
		ll minn=inf+1;
		for(int j=1;j<=n;j++)
		{
			if(minn>dis[j]&&!vis[j])
			{
				minn=dis[j];to=j;
			}
		}
	//	cout<<"find: "<<to<<" "<<dis[to]<<endl;
		vis[to]=1;//将起点加入到已经更新的数组中
		for(int j=1;j<=n;j++)
		{
			if(!vis[j])dis[j]=min(dis[j],dis[to]+t[to][j]);//更新dis数组
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	int m;
	cin>>n>>m>>S;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)t[i][j]=inf;//初始化图
	for(int i=1;i<=m;i++)
	{
		int u,v;ll w;
		cin>>u>>v>>w;
		t[u][v]=w;
	}
	dijkstra();
	for(int i=1;i<=n;i++)cout<<dis[i]<<" ";
	return 0;
}
```

#### djkjstra+堆优化

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=1e5+5;
const int maxm=2e5+5;
struct edge
{
	int to,next;
	ll w;
}e[maxm*2];
int head[maxn],cnt=0,S;
ll vis[maxn],dis[maxn];int n;
void add(int s,int to,ll w)
{
	e[++cnt].w=w;
	e[cnt].to=to;
	e[cnt].next=head[s];
	head[s]=cnt;
}
struct node
{
	int pos;ll dis;
	bool operator <(const struct node &b)const
	{
		return dis>b.dis;
	}
};
priority_queue<node>q;
void djk()
{
	for(int i=1;i<=n;i++)dis[i]=1e17;//dis的初始化
	dis[S]=0;
	q.push({S,0});
	while(!q.empty())
	{
		int s=q.top().pos;q.pop();//经过堆优化的也要像spfa一样。
        if(vis[s]==1)continue;vis[s]=1;
		for(int i=head[s];i;i=e[i].next)
		{
			int to=e[i].to;
			if(dis[to]>e[i].w+dis[s])
			{
				dis[to]=e[i].w+dis[s];
				if(vis[to]==0)q.push({to,dis[to]});
			}
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	int m;
	cin>>n>>m>>S;
	for(int i=1;i<=m;i++)
	{
		int u,v;ll w;
		cin>>u>>v>>w;
		add(u,v,w);
	}
	djk();
	for(int i=1;i<=n;i++)cout<<dis[i]<<" ";cout<<endl;
	return 0;
}
```

#### dijkstra+势能优化

### 差分约数

+ 求不等式组的可行解

  源点需要满足的条件：从原点出发，一定可以遍历到所有的边。

  步骤：

  + 先将每个不等式$x_i<=x_j+c_k$,转化为一条从$x_j$走到$x_i$,长度为$c_k$的一条边

  + 找到一个超级源点，使得该源点一定可以遍历到所有边

  + 从源点求一遍单源最短路

    结果1：如果存在负环，则原不等式组一定无解

    结果2：如果没有负环，则$dist[i]$,就是原不等式组的一个可行解

+ 如何求最大值或最小值

  结论：如果求的是最小值，则应该求最长路；如果求的是最大值，则应该求最短路。

  问题：如何转化$x_i<=c$,其中c是一个常数，这类的不等式

  方法：建立一个超级源点，0，然后建立0->i , 长度是c的边即可。

  以求$x_i$的最大值为例：求所有从$x_i$出发，构成的不等式链$x_i<=x_j+c_1<=x_k+c_2+c_1<=..<=c_1+c_2+..+c_k$​ 所计算出的上界,最终$x_i$的最大值等于所有上界的最小值。

  

### 寻找强连通分量

tarjon算法

+ 求取无向图的强连通分量只需要增加不回头的操作。

dfn[u]表示深度优先树的遍历到u结点的时间

low[u]表示从u或u的子孙结点出发通过反向边可以到达的最小深度优先数

其中low[u]由以下状态得到：
$$
low[u]=min\begin{cases}dfn[n]\\min\{low[v],\text{v是u的子孙结点，(u,v)是树边} \} \\ min\{dfn[v],\text{v与u邻接，且（u，v）为反向边}\}\end{cases}
$$
结合代码，我们发现low[u]确实是由这项中情况得到

强连通分量：

```c++
#include<stdio.h>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
const int maxn=+1e5+1e4+4;
const int maxm=1e5+1e4+5;
int n,m,ans,head[maxn],stack[maxn],top=0,visi[maxn],dfn[maxn],timer=0,low[maxn];ll f[maxn];
int color[maxn],cnt=0;
int u[maxm],v[maxn];
ll quan[maxn],nquan[maxn];ll res=0;
struct edge
{
	int to,next;
}e[maxm];
inline void add(int s,int to)
{
	e[++ans].to=to;
	e[ans].next=head[s];
	head[s]=ans;
} 
void dfs(int s)//tarjon算法获得强连通分量 
{
	stack[++top]=s;visi[s]=1;
	dfn[s]=low[s]=++timer;//dfn[]中存放的是深度优先树的遍历顺序,low[]对应第一种情况
	for(int i=head[s];i;i=e[i].next)
	{
		if(dfn[e[i].to]==0)
		{
			dfs(e[i].to);
			low[s]=min(low[s],low[e[i].to]);//low[u]可以被子孙几点种所具有的最小深度优先数更新,对应情况二。
		}
		else if(visi[e[i].to]==1)low[s]=min(low[s],dfn[e[i].to]);
        //low[u]可以被与u相邻的v通过反向边更新，当visi[v]=1是说明v已经被遍历过了，那么意味着v->u是深度优先树上的树边，u->v则是反向边，对应情况三。
	}
	if(low[s]==dfn[s])
	{   
        cnt++;
		color[s]=cnt;nquan[cnt]+=quan[s];visi[s]=0;//忘记变0，qwq!!!! 
		while(stack[top]!=s)
		{
			color[stack[top]]=cnt;
			visi[stack[top]]=0;
			nquan[cnt]+=quan[stack[top]];
			top--;
		}
		top--;
	}
}
void tp(int s)//记忆化搜索 ,不用按度入队 
{
//	cout<<s<<endl;
	ll maxsum=0;
	if(f[s]!=0)return ;
	f[s]=nquan[s];
	for(int i=head[s];i;i=e[i].next)
	{
		if(f[s]==0)tp(e[i].to);
		maxsum=max(maxsum,f[e[i].to]);
	}
	f[s]+=maxsum;
}
inline int read(){
    int x=0,ff=1; char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')ff=-1; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48; ch=getchar();}
    return ff*x;    
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++)cin>>quan[i];
	for(int i=1;i<=m;i++)
	{
		u[i]=read();v[i]=read();
		add(u[i],v[i]);
	}
	for(int i=1;i<=n;i++)if(dfn[i]==0)dfs(i);
	for(int i=1;i<=n;i++)head[i]=0;ans=0;
	for(int i=1;i<=m;i++)e[i].next=0,e[i].to=0;
	for(int i=1;i<=m;i++)
	{
		int uu=color[u[i]],vv=color[v[i]];
		if(uu!=vv)//建立一张新图 ，如果两点不在同一个强连通分量就连边 
		{
			add(uu,vv);
		}
	}
	ll result=0;
	for(int i=1;i<=cnt;i++)
	{	
		if(f[i]==0)tp(i);
		result=max(result,f[i]);
	}
	cout<<result<<endl;
	return 0;
} 

```

#### 割点

在给定的一张无向图上，删去某个点能够使得图不连通，该点便被称为割点。

如何利用tarjon寻找割点？

我们已知low的功能，记录子孙结点出发通过反向边可以到达的最小深度优先数

当我们发现一个**非根结点u**的某下一个结点v无法回到u，这也意味着当我们删除u后，以v为根的子图会和u的另一部分失去联通性，即u为割点。

若u是根结点，我们需要看根节点有几颗子树，如有多棵**子树**（在图的深度优先树意义上的子树），则为子树。

寻找个点代码：

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e4 + 4;
const int maxm = 1e5 + 5;
int head[maxn], cnt = 0, low[maxn], dfn[maxn], timer = 0, cut[maxn], ans = 0;
struct node {
	int to;
	int next;
}e[maxm*2];
void add(int s,int to)
{
	e[++cnt].to = to;
	e[cnt].next = head[s];
	head[s] = cnt;
}
void tarjon(int u,int fa)
{
	dfn[u] = low[u] = ++timer;
	int child = 0;
	for(int i=head[u];i;i=e[i].next)
	{
		int to = e[i].to;
		if(dfn[to]==0)
		{
			tarjon(to, fa);
			low[u] = min(low[u], low[to]);
			if(low[to]>=dfn[u]&&u!=fa)
			{
				cut[u] = 1; //如果发现他的子结点的low值大于等于dfn,那么说明当删去u后，以v为根的子树会脱离，连通性会改变。
			}
			if (u == fa)child++;
		}
		else low[u] = min(low[u], dfn[to]);
	}
	if (child >= 2 && u == fa)cut[fa] = 1;
}
int main()
{
	ios::sync_with_stdio(false);
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++)
	{
		int u, v;
		cin >> u >> v;
		add(u, v); add(v, u);
	}	
	for(int i=1;i<=n;i++)
	{
		timer = 0;
		if (dfn[i] == 0)tarjon(i, i);
	}
	for (int i = 1; i <= n; i++)if (cut[i] == 1)ans++;
	cout << ans << endl;
	for (int i = 1; i <= n; i++) 
	{
		if (cut[i] == 1)cout << i << " ";
	}
	return 0;
}
```

#### 割边

**定义**：在无向联通图G中,如果移除某条边后，图不再联通，称这样的边为割边。

**性质1**：一个具有n个顶点的无向图，至多包含n-1条割边。

同样可以使用tarjon算法来寻找割边：

如果无向图中的一条边(u,v)是割边，当且仅当(u,v)为生成树中的边，且满足dfn[u]<low[v].

沈阳站H题

```c++
z#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
#define ll long long
int head[maxn],cnt=1,low[maxn],dfn[maxn],timer=0;
struct edge
{
    int to,next;
    ll w;
    int flag=1;
}e[maxn*4];
ll res=2e9;
void add(int s,int to,ll w)
{
    e[++cnt].w=w;
    e[cnt].to=to;
    e[cnt].next=head[s];
    head[s]=cnt;
}
int tarjon(int s,int fa)
{
    int cot=0,child=0;
    dfn[s]=low[s]=++timer;
    for(int i=head[s];i;i=e[i].next)
    {
       
        cot++;child++;int f=1;
        int to=e[i].to;ll w=e[i].w; 
        if(dfn[to]==0)
        {
            int num=tarjon(to,s);cot+=num;
           // cout<<s<<" "<<e[i].to<<num<<endl;
            low[s]=min(low[s],low[to]);
            if(low[to]>dfn[s])
            {
                if(((num-1)/2)%2==0)res=min(res,w);
                else f=0,e[i].flag=e[i^1].flag=0;
            }
            else res=min(res,w);
            //cout<<"find:"<<s<<" "<<to<<" "<<num<<endl;
        }
        else if(to!=fa) low[s]=min(low[s],dfn[to]);
    }
    return cot;
}
int main()
{
    ios::sync_with_stdio(false);
    int n,m;
    cin>>n>>m;
    ll sum=0;
    for(int i=1;i<=m;i++)
    {
        int u,v;ll w;
        cin>>u>>v>>w;add(u,v,w);add(v,u,w);sum+=w;
    }
    if(m%2==0){cout<<sum<<endl;return 0;}
    else 
    {
        //cout<<1<<endl;
        tarjon(1,0);
        for(int  i=2;i<=cnt;i++)if(e[i].flag==1)res=min(res,e[i].w);
        cout<<sum-res<<endl;
    }
    return 0;
}
```



### 二分图

二分图、不存在奇数环、染色不存在矛盾

匈牙利算法，匹配、最大匹配、匹配点、增广路径

最小点覆盖、最大独立集、最小路径覆盖（最小路径重复点覆盖）

最大匹配数 = 最小点覆盖=总点数-最大独立集=总点数-最小路径覆盖

最优匹配，KM（最小费用流）

多重匹配（最大流）



### 匈牙利算法

二分图

二分图匹配：将点分为两个集合，每个集合之中的点没有相连的两点

最大匹配：匹配边最多的边

匈牙利算法是用来求二分图的最大匹配的，它的核心问题就是找增广路径。匈牙利算法的时间复杂度为O(VE)

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=510;
int line[maxn][maxn],used[maxn],nxt[maxn],n,m;
bool find(int x)
{
    for(int i=1;i<=m;i++)
    {
        if(line[x][i]==1&&used[i]==0)
        {
            used[i] = 1;//cout<<i<<" "<<nxt[i]<<endl;
            if(nxt[i] == 0||find(nxt[i]))//如果这个女生没有被匹配，或者这个女生匹配的男生能够被找到另外的女生匹配。
            {
                nxt[i] = x;
                return true;
            }
        }
    }
    return false;
}
int  match()
{
    int sum=0;
    for(int i=1;i<=n;i++)
    {	
        memset(used,0,sizeof(used));//需要对女生清空
        if(find(i))sum++;
    }
    return sum;
}
int main()
{
    ios::sync_with_stdio(false);
    int u,v,s;
    cin>>n>>m>>s;
    memset(nxt,0,sizeof(nxt));
    memset(line,0,sizeof(line));
    for(int i=1;i<=s;i++){
    cin>>u>>v;
    line[u][v]=1;}
    int res=match();
	cout<<res<<endl;
    return 0;
}
```

### 网络流

#### Dicnic算法

时间复杂度：O(N^2 *M);

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=205;//注意范围
const int maxm=5e3+5;
int n,m,S,T;
ll head[maxn],rad[maxn],dis[maxn],cnt=1;
struct edge
{
	int to,next;
	ll w;
}e[maxm*2];
void add(int s,int to,ll w)
{
	e[++cnt].to=to;
	e[cnt].w=w;
	e[cnt].next=head[s];
	head[s]=cnt;
}
bool bfs()
{
	memset(dis,0,sizeof(dis));
	queue<ll>q;dis[S]=1;q.push(S);
	while(!q.empty())
	{
		ll u=q.front();q.pop();rad[u]=head[u];
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to;
			if(dis[v]==0&&e[i].w!=0)dis[v]=dis[u]+1,q.push(v);
		}
	}
	return dis[T];
}
ll dfs(int now,ll rem)
{
	if(now==T)return rem;
	ll tem=rem;
	for(int i=rad[now];i;i=e[i].next)
	{
		int v=e[i].to;rad[now]=i;
		if(dis[v]==dis[now]+1&&e[i].w!=0)
		{
			ll k=min(e[i].w,tem);
			ll dlt=dfs(v,k);
			e[i].w-=dlt;e[i^1].w+=dlt;//cnt从1开始  dxfds
			tem-=dlt;
			if(!tem)break;//加速，无残量结束 
		}
	}
	return rem-tem;
}
int main()
{ 
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m>>S>>T;
	for(int i=1;i<=m;i++)
	{
		int u,v;ll w;
		cin>>u>>v>>w;
		add(u,v,w);
		add(v,u,0);
	} 
	ll res=0;
	while(bfs())res+=dfs(S,1e18);
	cout<<res<<endl; 
	
	return  0;
}
```

EK算法：O(n\*m\*m)

```c++
#include<iostream>
#include<cstring>
using namespace std;
const int N=1010,M=20010;

//h[i]存下以点i为起点的边的编号（按输入顺序，存下的是最后一条边的编号）
//f[i]存下边i的权值，e[i]存下边i的终点，ne[i]存下和边i同起点的上一条边的编号(可以依次找出同起点的所有边)
//idx用来记录边的编号
//p,d,pre三个数组在bfs寻找增广路径时使用，来记录当前搜到的边的信息，
//p[i]表示当前边的编号，d[i]表示走到这条边的路径中最小的边权值(最大的可行流量)，
//pre[i]表示当前这一条边是从之前的哪一条走过来的(记录的是bfs过程中的相应下标)
//tot用来记录bfs过程中展开的边的数量，下标为tot的位置是增广路径的最后一条边(其终点为t)
//n,m,s,t如题，mark用来标记bfs过程中已经到达了的点，防止重复搜索
int h[N]={0},f[M]={0},e[M]={0},ne[M]={0},idx=2;
int p[N]={0},d[N]={0},pre[N]={0},tot=0,n=0,m=0,s=0,t=0;
bool mark[N]={0};

//存下边的信息，同时要存下反向边，构建残余网络
void add(int& a,int& b,int& c){
    e[idx]=b;f[idx]=c;ne[idx]=h[a];h[a]=idx;idx++;
    e[idx]=a;f[idx]=0;ne[idx]=h[b];h[b]=idx;idx++;
}

//bfs找增广路径，结果记录在p,d,pre三个数组中
bool bfs(){
    int l=0;tot=0;//l是左端点，tot相当于右端点(每次重新置为0)
    memset(mark,0,sizeof(mark));//mark数组赋为false
    while(l<=tot){  //l<=tot,还要继续展开边
        //p[l]表示当前这条边的编号，e[p[l]]表示当前这条边的终点，h[e[p[l]]]表示以这一终点为顶点的一条边
        //通过ne数组不断找到以这一终点为顶点的所有边，for循环中的i就是这些边的编号
        for(int i=h[e[p[l]]];i;i=ne[i]){    //h数组的初始值为0，当i为0时表示以e[p[l]]为起点的边都搜过了
            if(!mark[e[i]]&&f[i]){//如果当前边的终点还没有到达过并且当前这条边的权值大于0，就会展开这一条边
                tot++;//右边界++,并标记上这条边的终点
                mark[e[i]]=1;
                //存下这条边，p[tot]存下编号i，
                //d[tot]存下路径中最小的权值(到达上一条边时最小权值d[l]和当前边i的权值中的最小值)
                //pre[tot]存下当前这一边是从下标l位置的那条边走过来的
                p[tot]=i;d[tot]=min(f[i],d[l]);pre[tot]=l;
                if(e[i]==t)return true;//当前这条边到达了终点，返回true
            }
        }
        l++;// l不要忘记++(因为我就忘了)，继续展开下一条边
    }
    return false;//没有找到增广路径辽~
}
int main(){
    std::ios::sync_with_stdio(false);
    cin>>n>>m>>s>>t;
    e[1]=s;//添加编号为1的边，其终点为s（边的其他信息没有管它，因为没有用到~~
    p[0]=1;d[0]=1e9;//bfs的起点是这条编号为1的边，当前最小权值赋成一个较大的值
    int a=0,b=0,c=0;
    while(m--){//输入边的信息，存下来
        cin>>a>>b>>c;
        add(a,b,c);
    }
    int ans=0;
    while(bfs()){//当前残网络中还可找到增广路径，则累加至ans中，并修改这条路径中正向边和反向边的权值
        ans+=d[tot];
        for(int i=tot;i;i=pre[i]){//从tot位置的边开始，沿着增广路径往回走，走到0位置的边(也就是边1时)停止
            //路径中的每一条边减去d[tot]，其反向边加上d[tot]
            f[p[i]]-=d[tot];f[p[i]^1]+=d[tot];
        }
    }
    cout<<ans<<endl;
    return 0;
}

```

#### 无源汇上下界可行流量

给定一个包含 n 个点 m 条边的有向图，每条边都有一个流量下界和流量上界。求一种可行方案使得在所有点满足流量平衡条件的前提下，所有边满足流量限制。

分析出发点：

+ 流量守恒
+ 满足流量限制

采用将上界和流量都减去下界的方式，使其满足:
$$
0<=f-C_{low}<=C_{up}-C_{low}
$$
这样就满足流量限制，但是并不满足流量守恒。

考虑某一汇点，流量守恒需要满足进入的总流量等于出去的总流量,

但由于进入的流量会减少总的$C_{in}$,出去的需要减少$C_{out}$,如果$C_{in}$>$C_{out}$就需要为该汇点补上$C_{in}$-$C_{out}$,反之就连上该点到汇点的边。 

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=205;
const int maxm=20200;
#define ll long long
const ll mod=998244353;
int n,m,S,T;
ll head[maxn],rad[maxn],dis[maxn],cnt=1,a[maxn];
struct edge{
  int to,next;
  ll w,lo,up,id;  
}e[maxm*2];
bool bfs()
{
  memset(dis,0,sizeof(dis));
  queue<ll>q;dis[S]=1;q.push(S);
  while(!q.empty())
  {
    ll u=q.front();q.pop();rad[u]=head[u];
    for(int i=head[u];i;i=e[i].next)
    {
      int v=e[i].to;
      if(dis[v]==0&&e[i].w!=0)dis[v]=dis[u]+1,q.push(v);
    }
  }
  return dis[T];
}
ll dfs(int now,ll rem)
{
  if(now==T)return rem;
  ll tem=rem;
  for(int i=rad[now];i;i=e[i].next)
  {
    int v=e[i].to;rad[now]=i;
    if(dis[v]==dis[now]+1&&e[i].w!=0)
    {
      ll k=min(e[i].w,tem);
      ll dlt=dfs(v,k);
      e[i].w-=dlt;e[i^1].w+=dlt;
      tem-=dlt;
      if(!tem)break;
    }
  }
  return rem-tem;
}
void add(int s,int to,ll w,ll lo,ll up,ll id)
{
  e[++cnt].to=to;
  e[cnt].w=w;
  e[cnt].lo=lo;e[cnt].up=up;e[cnt].id=id;
  e[cnt].next=head[s];
  head[s]=cnt;
}
int main()
{
  scanf("%d%d",&n,&m);
  for(int i=1;i<=m;i++)
  {
    int u,v,lo,up;
    scanf("%d%d%d%d",&u,&v,&lo,&up);
    add(u,v,up-lo,lo,up,0);
    add(v,u,0,lo,up,i);
    a[v]+=lo;
    a[u]-=lo;
  }
  S=0,T=n+1;
  ll sum=0;
  for(int i=1;i<=n;i++)
  {
     if(a[i]>0)add(S,i,a[i],0,0,0),add(i,S,0,0,0,0),sum+=a[i];//这部分全部流完了就可行
     else add(i,T,-a[i],0,0,0),add(T,i,0,0,0,0);
  }
  ll res=0;
  while(bfs())res+=dfs(S,1e10);
  if(sum!=res)cout<<"NO"<<'\n';
  else 
  {
    cout<<"YES"<<'\n';
    vector<int>ans(m+1);
    for(int i=1;i<=n;i++)
    {
      for(int j=head[i];j;j=e[j].next)
      {
        ans[e[j].id]=e[j].w+e[j].lo;
      }
    }
    for(int i=1;i<=m;i++)cout<<ans[i]<<'\n';
  }
  return 0;
}
```

#### 有源汇上下界最大流

考虑将其转化为无源汇网络，由于有源汇，故源点和汇点不满足流量守恒，故可以在无源汇的基础上连接一条T->S的无穷边，这样S和T都不需要满足流量守恒。

通过该方式建立了一个无汇源的上下界可行流，判断可不可行，然后在看s->t的最大流。

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=250;
const int maxm=20043;
int head[maxn],rad[maxn],cnt=1,A[maxn],dis[maxn];
int n,m,S,T;
struct egde{
  int next,to;
  ll w;  
}e[maxm*2];
void add(int s,int to,ll w)
{
  e[++cnt].to=to;
  e[cnt].w=w;
  e[cnt].next=head[s];
  head[s]=cnt;
  e[++cnt].to=s;
  e[cnt].w=0;
  e[cnt].next=head[to];
  head[to]=cnt;
}
bool bfs()
{
	memset(dis,0,sizeof(dis));
	queue<ll>q;dis[S]=1;q.push(S);
	while(!q.empty())
	{
		ll u=q.front();q.pop();rad[u]=head[u];
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to;
			if(dis[v]==0&&e[i].w!=0)dis[v]=dis[u]+1,q.push(v);
		}
	}
	return dis[T];
}
ll dfs(int now,ll rem)
{
	if(now==T)return rem;
	ll tem=rem;
	for(int i=rad[now];i;i=e[i].next)
	{
		int v=e[i].to;rad[now]=i;
		if(dis[v]==dis[now]+1&&e[i].w!=0)
		{
			ll k=min(e[i].w,tem);
			ll dlt=dfs(v,k);
			e[i].w-=dlt;e[i^1].w+=dlt;//cnt从1开始  dxfds
			tem-=dlt;
			if(!tem)break;//加速，无残量结束 
		}
	}
	return rem-tem;
}

int main()
{
  int s,t;
  scanf("%d%d%d%d",&n,&m,&s,&t);
  for(int i=1;i<=m;i++)
  {
    int u,v,l,r;
    scanf("%d%d%d%d",&u,&v,&l,&r);
    add(u,v,r-l);
    A[v]+=l;A[u]-=l;
  }
  S=0,T=n+1;
  ll sum=0;
  for(int i=1;i<=n;i++)
  {
    if(A[i]>0)add(S,i,A[i]),sum+=A[i];
    else if(A[i]<0)add(i,T,-A[i]);
  }
  add(t,s,1e12);
  ll res=0;
  while(bfs())res+=dfs(S,1e14);
  if(res!=sum)puts("No Solution");
  else 
  {
    //cout<<"YES"<<'\n';
    ll ans=e[cnt].w;//最大流等于可行流中的流量+新的最大流。
    e[cnt].w=e[cnt^1].w=0;
    S=s,T=t;
    while(bfs())ans+=dfs(s,1e15);
    cout<<ans<<'\n';
    
  }
  return 0;
}
```

#### 有源汇上下界最小流

同最大流一样，在得到s->t的流量后，尝试从t->s退流，退的最多，就是从s->t的最小流。

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=50006;
const int maxm=300005;
#define ll long long
int n,m,S,T;
ll head[maxn],rad[maxn],dis[maxn],cnt=1,A[maxn];
struct edge
{
	int to,next;
	ll w;
}e[maxm*2];
void add(int s,int to,ll w)
{
	e[++cnt].to=to;
	e[cnt].w=w;
	e[cnt].next=head[s];
	head[s]=cnt;
    e[++cnt].to=s;
    e[cnt].w=0;
    e[cnt].next=head[to];
    head[to]=cnt;
}
bool bfs()
{
	memset(dis,0,sizeof(dis));
	queue<ll>q;dis[S]=1;q.push(S);
	while(!q.empty())
	{
		ll u=q.front();q.pop();rad[u]=head[u];
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to;
			if(dis[v]==0&&e[i].w!=0)dis[v]=dis[u]+1,q.push(v);
		}
	}
	return dis[T];
}
ll dfs(int now,ll rem)
{
	if(now==T)return rem;
	ll tem=rem;
	for(int i=rad[now];i;i=e[i].next)
	{
		int v=e[i].to;rad[now]=i;
		if(dis[v]==dis[now]+1&&e[i].w!=0)
		{
			ll k=min(e[i].w,tem);
			ll dlt=dfs(v,k);
			e[i].w-=dlt;e[i^1].w+=dlt;//cnt从1开始  dxfds
			tem-=dlt;
			if(!tem)break;//加速，无残量结束 
		}
	}
	return rem-tem;
}
int main()
{
  int s,t;
  scanf("%d%d%d%d",&n,&m,&s,&t);
  for(int i=1;i<=m;i++)
  {
    ;ll u,v,l,r;
    scanf("%lld%lld%lld%lld",&u,&v,&l,&r);
    add(u,v,r-l);
    A[v]+=l;A[u]-=l;
  }
  S=n+1,T=n+2;
  ll sum=0;
  for(int i=1;i<=n;i++)
  {
    if(A[i]>0)add(S,i,A[i]),sum+=A[i];
    else if(A[i]<0)add(i,T,-A[i]);
  }
  add(t,s,1e18);
  ll res=0;
  while(bfs())res+=dfs(S,1e18);
  if(res!=sum)cout<<"No Solution"<<"\n";
  else 
  {
    ll ans=e[cnt].w;
    S=t,T=s;
    e[cnt].w=0;
    e[cnt-1].w=0;
    while(bfs())ans-=abs(dfs(S,1e18));
    cout<<ans<<'\n';   
  }
}

```

#### 最大流值关键边

在残网络上，关键边(u,v)：u->v满流，且存在S->u的增广路，v->T的未满路。

或者增加某个边权看是否出现增广路。

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=50006;
const int maxm=2e5+5;
#define ll long long
int n,m,S,T;
ll head[maxn],rad[maxn],dis[maxn],cnt=1,A[maxn];
struct edge
{
	int to,next;
	ll w;
}e[maxm*2];
void add(int s,int to,ll w)
{
	e[++cnt].to=to;
	e[cnt].w=w;
	e[cnt].next=head[s];
	head[s]=cnt;
  e[++cnt].to=s;
  e[cnt].w=0;
  e[cnt].next=head[to];
  head[to]=cnt;
}
bool bfs()
{
	memset(dis,0,sizeof(dis));
	queue<ll>q;dis[S]=1;q.push(S);
	while(!q.empty())
	{
		ll u=q.front();q.pop();rad[u]=head[u];
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to;
			if(dis[v]==0&&e[i].w!=0)dis[v]=dis[u]+1,q.push(v);
		}
	}
	return dis[T];
}
ll dfs(int now,ll rem)
{
	if(now==T)return rem;
	ll tem=rem;
	for(int i=rad[now];i;i=e[i].next)
	{
		int v=e[i].to;rad[now]=i;
		if(dis[v]==dis[now]+1&&e[i].w!=0)
		{
			ll k=min(e[i].w,tem);
			ll dlt=dfs(v,k);
			e[i].w-=dlt;e[i^1].w+=dlt;//cnt从1开始  dxfds
			tem-=dlt;
			if(!tem)break;//加速，无残量结束 
		}
	}
	return rem-tem;
}
ll get_dfs1(int now)
{
  for(int i=head[now];i;i=e[i].next)
  {
    int to=e[i].to;

  }
}
ll get_dfs2(int now)
{

}
int main()
{
  scanf("%d%d",&n,&m);
  for(int i=1;i<=m;i++)
  {
    int u,v,c;
    scanf("%d%d%d",&u,&v,&c);
    add(u,v,c);
  }
  S=0,T=n-1;
  ll res=0;
  while(bfs())res+=dfs(S,1e15);
  int ans=0;
  for(int i=2;i<=cnt;i+=2)
  {
    if(e[i].w!=0)continue;
    e[i].w++;
    if(bfs())ans++;
    e[i].w--;
  }
  cout<<ans<<'\n';
  return 0;
}
```

#### 最大流之最大流判定(分层图)

当网络流中遇到了多维度的信息时，需要考虑分层图。

#### 最大流之拆点

例子：每头牛，喜欢多种饮料，多种食物，为尽可能多的牛安排吃喝

饮料到牛限制关系，牛到食物限制，将牛拆开，限制数量为1.

![image-20220819201757348](D:\none_c\ACM\网络流拆点.png)

流量清除：在原来基础上建图，能加快网络流。

#### 最小割套路

这里整理一下**基本套路**。

对于某个条件C，需要a1,a2.......an都取，C才能取的这样的语句，可以转化为C对所有a连线，C只对源点连线。

对于某个条件C，需要a,b只取一个，C才能取的这样的语句，可以转化为a,b连线。

#### 最小割(01分数规划问题)

$$
\frac{\sum_{i=1}^{c}w<cd\\w}{c} < d\\\sum_{i=1}^{c}w<cd\\\sum_{i=1}^{c}w-cd<0\\
\sum_{i=1}^{c}(w_i-d)<0
$$

通过上述的转化可以利用二分来解决该类问题。

 ```c++
 #include<bits/stdc++.h>
 using namespace std;
 #define ll long long 
 const int maxn=110;
 const int maxm=810;
 int n,m,S,T;
 int head[maxn],rad[maxn],cnt=1,dis[maxn];
 struct node
 {
   int to,next;
   int rw;
   double w;
 }e[maxm];
 void add(int s,int to,int w)
 {
   e[++cnt].to=to;
   e[cnt].next=head[s];
   e[cnt].rw=w;
   head[s]=cnt;
   e[++cnt].to=s;
   e[cnt].next=head[to];
   e[cnt].rw=w;
   head[to]=cnt;
 }
 bool bfs()
 {
   memset(dis,0,sizeof dis);
   queue<int>q;q.push(S);dis[S]=1;
   while(q.size())
   {
     int s=q.front();q.pop();
     rad[s]=head[s];
     for(int i=head[s];i;i=e[i].next)
     {
       int to=e[i].to;
       if(dis[to]==0&&e[i].w!=0)
       {
         dis[to]=dis[s]+1;q.push(to);
       }
     }
   }
   return dis[T];
 }
 double dfs(int now,double rem)
 {
   if(now==T)return rem;
   double tem=rem;
   for(int i=rad[now];i;i=e[i].next)
   {
     rad[now]=i;
     int to=e[i].to;
     if(dis[to]==dis[now]+1&&e[i].w!=0)
     {
       double k=min(tem,e[i].w);
       double dlt=dfs(to,k);
       e[i].w-=dlt;e[i^1].w+=dlt;
       tem-=dlt;
       if(tem==0)break;
     }
   }
   return rem-tem;
 }
 bool check(double mid)
 {
   double ans=0;
   for(int i=2;i<=cnt;i+=2)
   {
 
     if(e[i].rw<=mid)ans+=e[i].rw-mid,e[i].w=e[i^1].w=0;
     else e[i].w=e[i^1].w=e[i].rw-mid;
     //if(mid>=1&&mid<=2)cout<<i/2<<" "<<e[i].to<<" "<<e[i].w<<'\n';
   }
   double res=0;
   while(bfs())res+=dfs(S,1e10);
   //cout<<mid<<" "<<res<<'\n';
   if(res+ans<=0)return true;
   return false;
 }
 
 int main()
 {
   scanf("%d%d%d%d",&n,&m,&S,&T);
   for(int i=1;i<=m;i++)
   {
     int u,v,w;
     scanf("%d%d%d",&u,&v,&w);
     add(u,v,w);
   }
   //cout<<cnt<<'\n';
   double ans=-1,l=0,r=1e10;
   while(l<=r)
   {
     double mid=(l+r)/2.0;
     if(check(mid)==true)ans=mid,r=mid-0.001;
     else l=mid+=0.001;
   }
   printf("%.2f\n",ans);
   return 0;
 }
 ```

#### 最小割应用(划分两个集合)

最小割常见模型之一，当我们需要将一个集合划分成两个部分，并让这两个集合间连接代价最小时，可以使用最小割模型。

建立虚拟源点和虚拟汇点。有些点最开始是有编号的，如果有些点的标号是 00，说明他一定要和源点在一个集合，那么我们就从源点向这些点连一条容量是 +∞ 的边，这样这些点就一定能从源点走到，这些点就必然不会和汇点在同一个集合，否则源点和汇点就在同一个集合，就矛盾了。如果有些点的标号是 1，说明这些点就必须和汇点在一个集合，同理从这些点向汇点连一条容量是 +∞ 的边。

#### 最小割求最大权闭合子图

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=510;
const int maxm=2e6+6;
int n,m,S,T;
int head[maxn],cnt=1,rad[maxn],dis[maxn],vis[maxn];
ll a[maxn];
struct node
{
  int to,next;
  ll w;
}e[maxm];
void add(int s,int to,ll w)
{
  e[++cnt].to=to;
  e[cnt].next=head[s];
  head[s]=cnt;
  e[cnt].w=w;
}
bool bfs()
{
  memset(dis,0,sizeof dis);
  queue<int>q;q.push(S);dis[S]=1;
  while(q.size())
  {
    int s=q.front();q.pop();rad[s]=head[s];
    for(int i=head[s];i;i=e[i].next)
    {
      int to=e[i].to;
      if(dis[to]==0&&e[i].w)
      {
        dis[to]=dis[s]+1;q.push(to);
      }
    }
  }
  return dis[T];
}
ll dfs(ll now,ll rem)
{
  if(now==T)return rem;
  ll tem=rem;
  for(int i=rad[now];i;i=e[i].next)
  {
    ll to=e[i].to;rad[now]=i;
    if(dis[to]==dis[now]+1&&e[i].w)
    {
      ll k=min(e[i].w,tem);
      ll dlt=dfs(to,k);
      e[i].w-=dlt;e[i^1].w+=dlt;
      tem-=dlt;
      if(tem==0)break;
    }
  }
  return rem-tem;
}
int main()
{
  scanf("%d%d",&n,&m);
  S=n+1,T=n+2;
  for(int i=1;i<=n;i++)add(S,i,0),add(i,S,0);
  for(int i=1;i<=n;i++)add(i,T,0),add(T,i,0);
  for(int i=1;i<=m;i++)
  {
    int u,v;
    scanf("%d%d",&u,&v);
    add(u,v,1);add(v,u,1);
  }
  int y;
  scanf("%d",&y);
  for(int i=1;i<=y;i++)
  {
    int x,k;
    scanf("%d%d",&x,&k);
    a[x]=k;
  }
  ll res=0;
  for(ll i=1;i<=34;i++)
  {
    for(int j=2;j<=cnt;j++)e[j].w=1;
    for(int j=1;j<=n;j++)
    {
      e[j*2+n*2].w=0;
      e[j*2+1+n*2].w=0;
      e[j*2].w=0;
      e[j*2+1].w=0;
      if(a[j])
      {
        if((a[j]>>(i-1))%2==0)
        {
          e[j*2].w=1e9;
          e[j*2+1].w=0;
        }
        else
        {
          e[j*2+n*2].w=1e9;
          e[j*2+1+n*2].w=0;
        }
      }
      //if(i==6)cout<<j<<" "<<e[j*2].w<<" "<<e[j*2+n*2].w<<'\n';
    }
    while(bfs())res+=(dfs(S,1e9)<<(i-1));
    //cout<<i<<" "<<res<<'\n';
  }
  cout<<res<<'\n';
  return 0;
}
```

最大权闭合子图(选课问题)

定义：

有一个有向图，每一个点都有一个权值（可以为正或负或0），选择一个权值和最大的子图，使得每个点的后继都在子图里面，这个子图就叫最大权闭合子图。

![有向图](https://img-blog.csdn.net/20170826170245647?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FuOTE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

解法：该问题可以被转化为最小割问题

从源点s向每个正权点连一条容量为权值的边，每个负权点向汇点t连一条容量为权值的绝对值的边，有向图原来的边容量全部为无限大。

![最小割建模](https://img-blog.csdn.net/20170826171031814?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FuOTE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

简单割：割边只出现在同汇点相连或同源点相连的边

**最大权闭合子图权值 = 所有权值为正的权值之和 - 最大流（最小割）**

模糊的理解：

想要的是从s流出的边权，假如流量成功流入汇点，说明流量一定经过了副边，那么就需要减去副边。

对于该图，从S出发被割去的点即为不选的正权，流入T被割去的几位要选的反边。

方案输出：由上可知应当选所有与源点相连的点。

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=5005+5e5+10;
const int maxm=2e6+6;
int head[maxn],cnt=1,rad[maxn],dis[maxn];
int n,m,S,T;
struct node
{
  int to,next;
  ll w;
}e[maxm*2];
void add(int s,int to,ll w)
{
  e[++cnt].to=to;
  e[cnt].next=head[s];
  e[cnt].w=w;
  head[s]=cnt;
  e[++cnt].to=s;
  e[cnt].next=head[to];
  e[cnt].w=0;
  head[to]=cnt;
}
bool bfs()
{
  memset(dis,0,sizeof dis);
  queue<int>q;q.push(S);dis[S]=1;
  while(q.size())
  {
    int s=q.front();rad[s]=head[s];q.pop();
    for(int i=head[s];i;i=e[i].next)
    {
      int to=e[i].to;
      if(dis[to]==0&&e[i].w!=0)
      {
        dis[to]=dis[s]+1;
        q.push(to);
      }
    }
  }
  return dis[T];
}
ll dfs(int now,ll rem)
{
  if(T==now)return rem;
  ll tem=rem;
  for(int i=rad[now];i;i=e[i].next)
  {
    int to=e[i].to;rad[now]=i;
    if(dis[to]==dis[now]+1&&e[i].w!=0)
    {
      ll k=min(e[i].w,tem);
      ll dlt=dfs(to,k);
      e[i].w-=dlt;e[i^1].w+=dlt;
      tem-=dlt;
      if(tem==0)break;
    }
  }
  return rem-tem;
}
int main()
{
  scanf("%d%d",&n,&m);
  S=0,T=n+m+1;
  ll sum=0;
  for(int i=1;i<=n;i++)
  {
    int x;
    scanf("%d",&x);
    add(i,T,x);//sum+=x;
  }
  for(int i=1;i<=m;i++)
  {
    int u,v,c;
    scanf("%d%d%d",&u,&v,&c);
    add(n+i,u,1e9);
    add(n+i,v,1e9);
    add(S,n+i,c);
    sum+=c;
  }
  ll res=0;
  while(bfs())res+=dfs(S,1e10);
  //cout<<sum<<" "<<res<<'\n';
  cout<<sum-res<<'\n';
  return 0;
}
```

#### 最小割最大密度子图

问题是对无向图定义的 ，可以转化为最大权闭合子图。

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110, M = (1000 + N * 2) * 2, INF = 1e8;

int n, m, S, T;
int h[N], e[M], ne[M], idx;
double f[M];
int q[N], d[N], cur[N];
int dg[N];

struct Edge
{
    int a, b;
}edges[M];

int ans;
bool st[N];

void add(int a, int b, double c1, double c2)
{
    e[idx] = b, f[idx] = c1, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = c2, ne[idx] = h[b], h[b] = idx ++ ;
}

void build(double g)
{
    memset(h, -1, sizeof h);
    idx = 0;
    for (int i = 0; i < m; i ++ ) add(edges[i].a, edges[i].b, 1, 1);
    for (int i = 1; i <= n; i ++ )
    {
        add(S, i, m, 0);
        add(i, T, m + g * 2 - dg[i], 0);
    }
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i] > 0)
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T) return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

double find(int u, double limit)
{
    if (u == T) return limit;
    double flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i] > 0)
        {
            double t = find(ver, min(f[i], limit - flow));
            if (t <= 0) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

double dinic(double g)
{
    build(g);
    double r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

void dfs(int u)
{
    st[u] = true;
    if (u != S) ans ++ ;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int ver = e[i];
        if (!st[ver] && f[i] > 0)
            dfs(ver);
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    S = 0, T = n + 1;

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        dg[a] ++, dg[b] ++ ;
        edges[i] = {a, b};
    }

    double l = 0, r = m;
    while (r - l > 1e-8)
    {
        double mid = (l + r) / 2;
        double t = dinic(mid);
        if (m * n - t > 0) l = mid;
        else r = mid;
    }

    dinic(l);
    dfs(S);

    if (!ans) puts("1\n1");
    else
    {
        printf("%d\n", ans);
        for (int i = 1; i <= n; i ++ )
            if (st[i])
                printf("%d\n", i);
    }
    return 0;
}
```

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
const double eps=1e-3;
const int maxn=1102;
const int maxm=2e6+6;
int n,m,S,T;
int head[maxn],cnt=1,rad[maxn],dis[maxn];
struct node
{
  int to,next;
  double w,rw;  
}e[maxm*2];
void add(int s,int to,double w)
{
  e[++cnt].to=to;
  e[cnt].w=w;e[cnt].rw=w;
  e[cnt].next=head[s];
  head[s]=cnt;
  e[++cnt].to=s;
  e[cnt].w=0;e[cnt].rw=0;
  e[cnt].next=head[to];
  head[to]=cnt;
}
bool bfs()
{
  memset(dis,0,sizeof dis);
  queue<int>q;q.push(S);dis[S]=1;
  while(q.size())
  {
    int s=q.front();q.pop();
    rad[s]=head[s];
    for(int i=head[s];i;i=e[i].next)
    {
      int to=e[i].to;
      if(dis[to]==0&&e[i].w!=0)
      {
        dis[to]=dis[s]+1;q.push(to);
      }
    }
  }
  return dis[T];
}
double dfs(int now,double rem)
{
  if(now==T)return rem;
  double tem=rem;
  for(int i=rad[now];i;i=e[i].next)
  {
    rad[now]=i;
    int to=e[i].to;
    if(dis[to]==dis[now]+1&&e[i].w!=0)
    {
      double k=min(tem,e[i].w);
      double dlt=dfs(to,k);
      e[i].w-=dlt;e[i^1].w+=dlt;
      tem-=dlt;
      if(tem==0)break;
    }
  }
  return rem-tem;
}
bool check(double mid)
{
  for(int i=2;i<=cnt;i++)e[i].w=e[i].rw;
  for(int i=1;i<=n;i++)e[i*2].w=mid;
  double res=0;
  while(bfs()){res+=dfs(S,1e8);}
  if(m-res>0)return true;
  return false;
}
int st[maxn],rest=0;
void get(int x)
{
    st[x]=1;if(x<=n&&x>=1)rest++;
    for(int i=head[x];i;i=e[i].next)
    {
        if(e[i].w>0&&st[e[i].to]==0)get(e[i].to);
    }
}
int main()
{
  cin>>n>>m;
  S=0,T=n+m+1;
  for(int i=1;i<=n;i++)add(i,T,0);
  for(int i=1;i<=m;i++)add(S,n+i,1);
  for(int i=1;i<=m;i++)
  {
    int u,v;
    cin>>u>>v;
    add(n+i,u,1e8);
    add(n+i,v,1e8);
  }
  double l=0,r=m,ans=0.0;
  while (r - l > 1e-4)
    {
        double mid = (l + r) / 2;
        
        if (check(mid)) l = mid;
        else r = mid;
    }
  check(l);get(S);
  if(rest==0){cout<<"1\n1\n";return 0;}
  cout<<rest<<'\n';
  for(int i=1;i<=n;i++)if(st[i]==1)cout<<i<<'\n';
  return 0;  
}
```



#### 二分图互斥选点

#### ![img](file:///C:\Users\86187\AppData\Roaming\Tencent\Users\2211979172\QQ\WinTemp\RichOle\65QQLFOF69`LEDQWO3_YVYV.png)

经典题目：方格取数

最小割模型

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=1e4+4;
const int maxm=4e5+4;
ll a[105][105];
struct node
{
	int to,next;
	ll w;
}e[maxm*2];
int S,T,n,m,head[maxn],dis[maxn],rad[maxn],cnt=1;
void add(int s,int to,ll w)
{
	e[++cnt].to=to;e[cnt].w=w;e[cnt].next=head[s];head[s]=cnt;
	e[++cnt].to=s;e[cnt].w=0;e[cnt].next=head[to];head[to]=cnt;
}
bool bfs()
{
	memset(dis,0,sizeof(dis));
	queue<ll>q;q.push(S);dis[S]=1;
	while(!q.empty())
	{
		int s=q.front();q.pop();rad[s]=head[s];
		for(int i=head[s];i;i=e[i].next)
		{
			int to=e[i].to;
			if(dis[to]==0&&e[i].w)
			{
				dis[to]=dis[s]+1;q.push(to);
			}
		}
	}
	return dis[T];	
}
ll dfs(int now,ll rem)
{
	if(now==T)return rem;
	ll tmp=rem;
	for(int i=rad[now];i;i=e[i].next)
	{
		int to=e[i].to;rad[now]=i;
		if(dis[to]==dis[now]+1&&e[i].w)
		{
			ll k=min(e[i].w,tmp);
			ll dlt=dfs(to,k);
			e[i].w-=dlt,e[i^1].w+=dlt;
			tmp-=dlt;
			if(!tmp)break; 
		}
	}
	return rem-tmp;
}
int main(){
    /*将图分为二分图*/
	ios::sync_with_stdio(false);
	ll sum=0;
	cin>>m>>n;S=n*m+1;T=n*m+2;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)cin>>a[i][j],sum+=a[i][j];
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		if((i+j)%2==1)
		{
			add(S,(i-1)*n+j,a[i][j]);//棋盘中的为黑色的点和起点连边
			if(i>1)add((i-1)*n+j,(i-2)*n+j,1e17);//将互斥的两点连边流量为inf
			if(j>1)add((i-1)*n+j,(i-1)*n+j-1,1e17);
			if(i<m)add((i-1)*n+j,i*n+j,1e17);
			if(j<n)add((i-1)*n+j,(i-1)*n+j+1,1e17);
		}
		else 
		{
			add((i-1)*n+j,T,a[i][j]);//棋盘中的为白色的点和终点连边	
		}
	}
	ll res=0;
	while(bfs())res+=dfs(S,1e18);
	
	cout<<sum-res<<endl;
	return 0;
}
```



**最大流=最小割**

#### 最小点权覆盖问题

完全图的问题是NP问题，因此此题都是二分图。

中间边的含义是非A即B

处理负权，先把负权点全部选上，然后删去，然后在跑最小点权覆盖

如果所有点权都是1的话：

最大匹配数=最小点覆盖数=n-最大独立集数。

在二分图中想要找到最小点权覆盖，只需要将二分图的简单割与最小点权覆盖一一对应，即每一种最小点权覆盖都对应着一种简单割，故求出简单割即可。

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=210;
const int maxm=2e6+6;
int n,m,S,T;
int head[maxn],cnt=1,rad[maxn],dis[maxn];
struct node
{
  int to,next;
  ll w;
}e[maxm*2];
void add(int s,int to,ll w)
{
  e[++cnt].to=to;
  e[cnt].w=w;
  e[cnt].next=head[s];
  head[s]=cnt;
  e[++cnt].to=s;
  e[cnt].w=0;
  e[cnt].next=head[to];
  head[to]=cnt;
}
bool bfs()
{
  memset(dis,0,sizeof dis);
  queue<int>q;q.push(S);dis[S]=1;
  while(q.size())
  {
    int s=q.front();q.pop();rad[s]=head[s];
    for(int i=head[s];i;i=e[i].next)
    {
      int to=e[i].to;
      if(dis[to]==0&&e[i].w)
      {
        dis[to]=dis[s]+1;q.push(to);
      }
    }
  }
  return dis[T];
}
ll dfs(int now,ll rem)
{
  if(now==T)return rem;
  ll tem=rem;
  for(int i=rad[now];i;i=e[i].next)
  {
    int to=e[i].to;rad[now]=i;
    if(dis[to]==dis[now]+1&&e[i].w)
    {
      ll k=min(e[i].w,tem);
      ll dlt=dfs(to,k);
      e[i].w-=dlt;e[i^1].w+=dlt;
      tem-=dlt;
      if(tem==0)break;
    }
  }
  return rem-tem;
}
int st[maxn];
void get_st(int s)
{
  st[s]=1;
  for(int i=head[s];i;i=e[i].next)
  {
    if(st[e[i].to]==0&&e[i].w)get_st(e[i].to);
  }
}
int main()
{
  cin>>n>>m;
  S=0,T=n*2+1;
  for(int i=1;i<=n;i++)
  {
    int w;cin>>w;
    add(S,i,w);
  }
  for(int i=1;i<=n;i++)
  {
    int w;cin>>w;
    add(i+n,T,w);
  }
  for(int i=1;i<=m;i++)
  {
    int u,v;
    cin>>u>>v;
    add(v,u+n,1e9);
  }
  ll res=0;
  while(bfs())res+=dfs(S,1e9);
  cout<<res<<'\n';
  get_st(S);
  vector<pair<int,char>>ans;
  for(int i=2;i<=cnt;i+=2)//遍历所有正向边
  {
    int s=e[i^1].to,to=e[i].to;
    if(st[s]==1&&st[to]==0)
    {
      if(s==S)ans.push_back({to,'+'});
      else if(to==T)ans.push_back({s-n,'-'});
    }
  }
  cout<<ans.size()<<'\n';
  for(int i=0;i<ans.size();i++)cout<<ans[i].first<<" "<<ans[i].second<<'\n';
  return 0;
}
```

#### 最大权独立集问题

两者都只能解决非负权值

独立集就是，就是一个点集，点集中的各点没有关系。
最大独立集就是，点的个数最多的独立集。

最大权独立集 = 所有点的总权值 - 最小权点覆盖

一般需要把原图分成两个部分，一部分和另一部分有限制。

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e4+10;
const int maxm=2e6+6;
#define ll long long
int n,m,S,T;
int head[maxn],cnt=1,rad[maxn],dis[maxn];
int xx[]={0,0,-1,1};
int yy[]={-1,1,0,0};
struct node
{
  int to,next;
  ll w;
}e[maxm];
void add(int s,int to,ll w)
{
  e[++cnt].to=to;
  e[cnt].next=head[s];
  e[cnt].w=w;
  head[s]=cnt;
  e[++cnt].to=s;
  e[cnt].next=head[to];
  e[cnt].w=0;
  head[to]=cnt;
}
bool bfs()
{
  memset(dis,0,sizeof dis);
  queue<int>q;q.push(S);dis[S]=1;
  while(q.size())
  {
    int s=q.front();q.pop();rad[s]=head[s];
    for(int i=head[s];i;i=e[i].next)
    {
      int to=e[i].to;
      if(dis[to]==0&&e[i].w)
      {
        dis[to]=dis[s]+1;q.push(to);
      }
    }
  }
  return dis[T];
}
ll dfs(int now,ll rem)
{
  if(now==T)return rem;
  ll tem=rem;
  for(int i=rad[now];i;i=e[i].next)
  {
    int to=e[i].to;rad[now]=i;
    if(dis[to]==dis[now]+1&&e[i].w)
    {
      ll k=min(e[i].w,tem);
      ll dlt=dfs(to,k);
      e[i].w-=dlt;e[i^1].w+=dlt;
      tem-=dlt;
      if(tem==0)break;
    }
  }
  return rem-tem;
}
int change(int i,int j)
{
  return (i-1)*m+j;
}
int main()
{
  ios::sync_with_stdio(false);
  cin>>n>>m;
  S=n*m*2+1,T=n*m*2+2;
  ll sum=0;
  for(int i=1;i<=n;i++)
  {
    for(int j=1;j<=m;j++)
    {
      int x;
      cin>>x;
      sum+=x;
      if((i+j)%2==1){
        for(int k=0;k<4;k++)
        {
          int ni=i+xx[k],nj=j+yy[k];
          if(ni>n||ni<1||nj>m||nj<1)continue;
          add(change(i,j),change(ni,nj),1e9);
        }
        add(S,change(i,j),x);
      }
      else add(change(i,j),T,x);
    }
  }
  ll res=0;
  while(bfs())res+=dfs(S,1e15);
  cout<<sum-res<<'\n';

  return 0;
}

```



#### 最小路径覆盖问题

给定一张DAG（有向无环图），n将其划分为多个集合，集合存放的是同一路径上的点，现在求集合数量最少的划分方案。

**最小路径覆盖数=|G|-二分图最大匹配数（|Ｇ|是有向图中的总边数）**

讲一下思路吧，套路的拆点，将每个点拆成两个，一个入点，一个出点，

如果原图中两个点之间有一条有向边，那么就将拆点后的图该点的出点连一条容量为1的边到另一点的入点，

然后建立一个超源，超汇，把超源向每个出点连边，入点向超汇连边，然后跑最大流。

每条路径的开头就是入点中没有匹配的点，跑最大流的时候记录一下每个入点对应的出点就行了。

大家都吐槽此题没写special judge，所以用vector邻接表输出方案会不对，

所以蒟蒻为自己曾是一名pas党感到庆幸，因为pascal的邻接表写法就是大家说的链式前向星，

时空常数比较小^_^，写习惯了，就不咋用vector了。

二分图定理之一：最小路径覆盖数=顶点数-最大匹配，这个应该都知道吧？

#### 最小费用最大流

最大可行流数值唯一，但方案不唯一，现在想要找到最小费用的。

EK：BFS()-> safa()  不可解决负权回路

最小费用最大流，即求在保证最大流量下，所需花费的最小费用。对于每一条边都有一个容量和费用，可以通过费用除以流量，来获得的单位流量，单位流量可以看作距离，最小费用即为流量*最短路径。

spfa

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=5010;
const int maxm=100010;
#define ll long long
int n,m,S,T;
int cnt=1,head[maxn],dis[maxn],q[maxn],incf[maxn],pre[maxn];
bool st[maxn];
struct node
{
  int to,next;
  ll f,w;
}e[maxm];
void add(int s,int to,int f,int w)
{
	//cout<<s<<" "<<to<<" "<<f<<" "<<w<<'\n';
  e[++cnt].to=to;e[cnt].f=f;e[cnt].w=w;e[cnt].next=head[s];head[s]=cnt;
  e[++cnt].to=s;e[cnt].f=0;e[cnt].w=-w;e[cnt].next=head[to];head[to]=cnt;
}
bool spfa()
{
  int hh=0,tt=1;
  for(int i=1;i<=n;i++)dis[i]=1e8;
  memset(incf,0,sizeof incf);
  q[0]=S,dis[S]=0,incf[S]=1e8;
  while(hh!=tt)
  {
    int s=q[hh++];
    //cout<<s<<'\n';
    if(hh==maxn)hh=0;
    st[s]=false;
    for(int i=head[s];i;i=e[i].next)
    {
      int to=e[i].to;
      if(e[i].f&&dis[to]>dis[s]+e[i].w)
      {
	  	  //cout<<to<<" "<<dis[to]<<" "<<dis[s]<<" "<<e[i].f<<'\n';
          dis[to]=dis[s]+e[i].w;
          pre[to]=i;
          incf[to]=min(e[i].f,(ll)incf[s]);
          if(!st[to])
          {
            q[tt++]=to;
            if(tt==maxn)tt=0;
            st[to]=true;
          }
      }
    }
  }
  return incf[T];
  //cout<<"ok!"<<'\n';
}
void EK(int &flow,int&cost)
{
  flow = cost =0;
  while(spfa())
  {
    int t=incf[T];
    flow+=t,cost+=t*dis[T];
    for(int i=T;i!=S;i=e[pre[i]^1].to)
    {
      e[pre[i]].f-=t;
      e[pre[i]^1].f+=t;

    }
  }
}
int main()
{
  scanf("%d%d%d%d",&n,&m,&S,&T);
  memset(head,0,sizeof head);
  for(int i=1;i<=m;i++)
  {
    int s,to,f,w;
    scanf("%d%d%d%d",&s,&to,&f,&w);
    
    add(s,to,f,w);
  }
  
  int flow,cost;
  EK(flow,cost);//cout<<"ok!"<<'\n';
  cout<<flow<<" "<<cost<<'\n';
  return 0;
}

```

最大费用最大流

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int  maxn = 160;
const int  maxm = 50 * 100 + 10;
int n, m, S, T;
int head[maxn], cnt = 1, dis[maxn], pre[maxn], q[maxn];
ll incf[maxn];
bool vis[maxn];
struct node
{
	int to, next;
	ll w, f, rw, rf;
}e[maxm * 2];
void add(int s, int to, int f, int w)
{
	//cout << s << " " << to << " " << f << " " << w << '\n';
	e[++cnt].to = to; e[cnt].next = head[s]; e[cnt].f = f; e[cnt].w = w; head[s] = cnt; e[cnt].rf = f, e[cnt].rw = w;
	e[++cnt].to = s; e[cnt].next = head[to]; e[cnt].f = 0; e[cnt].w = -w; head[to] = cnt; e[cnt].rf = e[cnt].f; e[cnt].rw = e[cnt].w;
}
bool spfa()
{
	memset(dis, 0x3f, sizeof dis);
	memset(incf, 0, sizeof incf);
	memset(pre, 0, sizeof pre);
	int hh = 0, tt = 1;
	q[0] = S; dis[S] = 0; incf[S] = 1e16;
	while (hh != tt)
	{
		int s = q[hh++]; //cout << s<<" "<<dis[s] << '\n';
		if (hh == maxn)hh = 0;
		vis[s] = false;
		for (int i = head[s]; i; i = e[i].next)
		{
			int to = e[i].to;
			if (e[i].f&&dis[to] > dis[s] + e[i].w)
			{
				
				dis[to] = dis[s] + e[i].w;
				pre[to] =i ;//cout << to << " " << dis[to] << '\n';
				incf[to] = min(e[i].f, (ll)incf[s]);
				if (vis[to] == false)
				{
					q[tt++] = to;
					if (tt == maxn)tt = 0;
					vis[to] = true;
				}
			}
		}
	}
	//cout << "ok:" << incf[T] << '\n';
	return incf[T];
}
void EK(ll &flow, ll &cost)
{
	flow = 0, cost = 0;
	while (spfa())
	{
		flow += incf[T];
		cost += 1ll * incf[T] * dis[T];
		for (int i = T; i != S; i = e[pre[i] ^ 1].to)
		{
			//cout << i << "\n";
			e[pre[i]].f -= incf[T];
			e[pre[i] ^ 1].f += incf[T];
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> n >> m;
	S = n + m + 1, T = n + m + 2;
	for (int i = 1; i <= n; i++)
	{
		int x;
		cin >> x;
		add(S, i, x, 0);
	}
	for (int i = 1; i <= m; i++)
	{
		int x;
		cin >> x;
		add(i + n, T, x, 0);
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			int x;
			cin >> x;
			add(i, n + j, 1e8, x);
		}
	}//cout << "ok!" << '\n';
	ll flow, cost;
	EK(flow, cost);
	cout << cost << '\n';
	for (int i = 0; i <= cnt; i++)
	{
		e[i].f = e[i].rf;
		e[i].w = -e[i].w;
	}
	flow = 0, cost = 0;
	EK(flow,cost);
	cout << -cost << '\n';
	return 0;
}
```





消圈法

```c++
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<algorithm>
#include<ctime>
#include<cctype>
#include<cmath>
#include<string>
#include<cstring>
#include<stack>
#include<queue>
#include<list>
#include<vector>
#include<map>
#include<set>
#define sqr(x) ((x)*(x))
#define LL long long
#define itn int
#define INF 0x3f3f3f3f
#define PI 3.1415926535897932384626
#define eps 1e-10
#define maxm (65536)
#define maxn (202)
 
using namespace std;
 
struct __point
{
    int x,y,p;
}b[101],sh[101];
int n,m;
 
int fir[maxn];
int u[maxm],v[maxm],cap[maxm],flow[maxm],cost[maxm],nex[maxm];
int e_max;
int q[maxn],d[maxn],prev[maxn],cnt[maxn];
bool inq[maxn];
 
int G[101][101];
int shelter[101];
bool vis[maxn];
 
void add_edge(int _u,int _v,int _cap,int _cost,int _f)
{
    int e;
    e=e_max++;
    u[e]=_u;v[e]=_v;cap[e]=_cap;cost[e]=_cost;flow[e]=_f;
    nex[e]=fir[u[e]];fir[u[e]]=e;
    e=e_max++;
    u[e]=_v;v[e]=_u;cap[e]=0;cost[e]=-_cost;flow[e]=-_f;
    nex[e]=fir[u[e]];fir[u[e]]=e;
}
 
int negative_loop(int s,int t)
{
    int f,r,top=-1;
    f=0;r=-1;
 
    memset(cnt,0,sizeof cnt);
    memset(d,0,sizeof d);
    memset(inq,1,sizeof inq);//inq是bool类型的数组，每一个元素占1字节，所以能够这样
    memset(prev,-1,sizeof prev);
    for (int i=s;i<=t;i++)
        q[++r]=i;
 
    while (f<=r)
    {
        int x=q[r--];//栈式写法。r--改成f++就是队列了。队列要将数组扩大。
        inq[x]=false;
        for (int e=fir[x];~e;e=nex[e])
        {
            if (cap[e]>flow[e] && d[v[e]]>d[u[e]]+cost[e])
            {
                d[v[e]]=d[u[e]]+cost[e];
                prev[v[e]]=e;
                if (!inq[v[e]])
                {
                    q[++r]=v[e];
                    inq[v[e]]=true;
                    cnt[v[e]]++;
                    if (cnt[v[e]]>t-s+1)    return v[e];
                    //如过不想推断边界。就把这个值调大些，由于假设没有负环就不会进队/栈那么多次，假设有负环，就会无限循环下去
                }
            }
        }
    }
 
    return -1;
}
 
 
inline int __cost(const __point &p1,const __point &p2)
{
    return abs(p1.x-p2.x)+abs(p1.y-p2.y)+1;
}
 
int main()
{
    #ifndef ONLINE_JUDGE
        freopen("/home/fcbruce/文档/code/t","r",stdin);
    #endif // ONLINE_JUDGE
 
    int p;
    int s,t;
    scanf("%d%d",&n,&m);
    s=0;t=n+m+1;
    e_max=0;
    memset(fir,-1,sizeof fir);
 
    for (int i=0;i<n;i++)
    {
        scanf("%d%d%d",&b[i].x,&b[i].y,&b[i].p);
        add_edge(s,i+1,b[i].p,0,b[i].p);
    }
 
    for (int i=0;i<m;i++)
    {
        scanf("%d%d%d",&sh[i].x,&sh[i].y,&sh[i].p);
    }
 
    memset(shelter,0,sizeof shelter);
    for (int i=0;i<n;i++)
    {
        for (int j=0;j<m;j++)
        {
            scanf("%d",&p);
            shelter[j]+=p;
            add_edge(i+1,n+j+1,INF,__cost(b[i],sh[j]),p);
        }
    }
 
    for (int i=0;i<m;i++)
    {
        add_edge(i+1+n,t,sh[i].p,0,shelter[i]);
    }
 
    int k=negative_loop(s,t);
 
    if (k!=-1)
    {
        puts("SUBOPTIMAL");
        memset(vis,0,sizeof vis);
 
        for (int e=prev[k];!vis[v[e]];e=prev[u[e]])//往前找负环
        {
            vis[v[e]]=true;
            k=v[e];
        }
 
        for (int e=prev[k];;e=prev[u[e]])//在负环中增广
        {
            flow[e]++;//仅仅要找一个更优的解。+1即可
            flow[e^1]--;
            if (u[e]==k)break;
        }
 
        for (int e=0;e<e_max;e++)
        {
            if (u[e]>0 && u[e]<=n && v[e]>n && v[e]<=n+m)
                G[u[e]-1][v[e]-n-1]=flow[e];
        }
 
        for (int i=0;i<n;i++)
        {
            for (int j=0;j<m;j++)
            {
                if (j) putchar(' ');
                printf("%d",G[i][j]);
            }
            putchar('\n');
        }
    }
    else
        puts("OPTIMAL");
 
 
    return 0;
}
```

djkstra求带父权的算法

```c++
bool dijkstra(int begin,int end)
{
	len=0;//使用的是手写堆，所以这里我要每次清零。可以忽略
	for(int i=1;i<=n;i++)
	{
		dis[i]=0x7fffffff;
		flow[i]=0x7fffffff;
		from[i]=L[i]=vis[i]=0;
	}
	dis[begin]=0;
	Data pas;//Data 有两个成员变量，一个是p表示点，d表示最短路
	pas.p=begin;pas.d=0;
	push(pas);//压入
	while(len)//手写堆怪我喽
	{
		pas=top();pop();
		while(vis[pas.p]&&len>=1)
		{
			pas=top();
			pop();
		}
		if(vis[pas.p]&&!len)	break;//想怎么出堆就这么出堆
		vis[pas.p]=true;
		dis[pas.p]=pas.d;//保存数据，好像也不用qwq
		for(int i=head[pas.p];i!=-1;i=line[i].nxt)//遍历邻接表
        //line是邻接表，其中有四个成员变量，p为所指向的点，w为边权，f为流量，nxt为.......邻接表的next指针qwq
			if(line[i].f>0&&!vis[line[i].p]&&dis[line[i].p]>dis[pas.p]+line[i].w+h[pas.p]-h[line[i].p])//判断，带上势
			{
				dis[line[i].p]=dis[pas.p]+line[i].w+h[pas.p]-h[line[i].p];//跟spfa一样的套路，就是多了个势
				flow[line[i].p]=min(line[i].f,flow[pas.p]);
				from[line[i].p]=pas.p;//到这个点的流量
				L[line[i].p]=i;//所被增广的边的编号
				Data nxt;
				nxt.p=line[i].p;nxt.d=dis[line[i].p];//压入堆，感觉自己写的好冗杂qwq
				push(nxt);
			}
	}
	return dis[end]!=0x7fffffff;//判断是否可以增广qwq
}
void MCMA(int begin,int end)
{
	while(dijkstra(begin,end))//差不多跟spfa一样的格式，就是加了个h数组
	{
		int max_flow=flow[end];
		Min_cost+=max_flow*(dis[end]-h[begin]+h[end]);//此处要减掉，才能保证正确性qwq
		Max_flow+=max_flow;
		for(int i=end;i!=begin;i=from[i])
		{
			line[L[i]].f-=max_flow;
			line[L[i]^1].f+=max_flow;
		}
		for(int i=1;i<=n;i++)
			h[i]+=dis[i];//累加，一定要累加，虽然不累加可能过几个点
	}
}
```



### KM算法

1.复杂度o(n4)->o(n3)

2.适用范围:带权二分图的最佳匹配。

```c++
#include <iostream>
#include <cstring>
#include <cstdio>
 
using namespace std;
const int MAXN = 305;
const int INF = 0x3f3f3f3f;
 
int love[MAXN][MAXN];   // 记录每个妹子和每个男生的好感度
int ex_girl[MAXN];      // 每个妹子的期望值
int ex_boy[MAXN];       // 每个男生的期望值
bool vis_girl[MAXN];    // 记录每一轮匹配匹配过的女生
bool vis_boy[MAXN];     // 记录每一轮匹配匹配过的男生
int match[MAXN];        // 记录每个男生匹配到的妹子 如果没有则为-1
int slack[MAXN];        // 记录每个汉子如果能被妹子倾心最少还需要多少期望值
 
int N;
 
 
bool dfs(int girl)
{
    vis_girl[girl] = true;
 
    for (int boy = 0; boy < N; ++boy) {
 
        if (vis_boy[boy]) continue; // 每一轮匹配 每个男生只尝试一次
 
        int gap = ex_girl[girl] + ex_boy[boy] - love[girl][boy];
 
        if (gap == 0) {  // 如果符合要求
            vis_boy[boy] = true;
            if (match[boy] == -1 || dfs( match[boy] )) {    // 找到一个没有匹配的男生 或者该男生的妹子可以找到其他人
                match[boy] = girl;
                return true;
            }
        } else {
            slack[boy] = min(slack[boy], gap);  // slack 可以理解为该男生要得到女生的倾心 还需多少期望值 取最小值 备胎的样子
        }
    }
 
    return false;
}
 
int KM()
{
    memset(match, -1, sizeof match);    // 初始每个男生都没有匹配的女生
    memset(ex_boy, 0, sizeof ex_boy);   // 初始每个男生的期望值为0
 
    // 每个女生的初始期望值是与她相连的男生最大的好感度
    for (int i = 0; i < N; ++i) {
        ex_girl[i] = love[i][0];
        for (int j = 1; j < N; ++j) {
            ex_girl[i] = max(ex_girl[i], love[i][j]);
        }
    }
 
    // 尝试为每一个女生解决归宿问题
    for (int i = 0; i < N; ++i) {
 
        fill(slack, slack + N, INF);    // 因为要取最小值 初始化为无穷大
 
        while (1) {
            // 为每个女生解决归宿问题的方法是 ：如果找不到就降低期望值，直到找到为止
 
            // 记录每轮匹配中男生女生是否被尝试匹配过
            memset(vis_girl, false, sizeof vis_girl);
            memset(vis_boy, false, sizeof vis_boy);
 
            if (dfs(i)) break;  // 找到归宿 退出
 
            // 如果不能找到 就降低期望值
            // 最小可降低的期望值
            int d = INF;
            for (int j = 0; j < N; ++j)
                if (!vis_boy[j]) d = min(d, slack[j]);
 
            for (int j = 0; j < N; ++j) {
                // 所有访问过的女生降低期望值
                if (vis_girl[j]) ex_girl[j] -= d;
 
                // 所有访问过的男生增加期望值
                if (vis_boy[j]) ex_boy[j] += d;
                // 没有访问过的boy 因为girl们的期望值降低，距离得到女生倾心又进了一步！
                else slack[j] -= d;
            }
        }
    }
 
    // 匹配完成 求出所有配对的好感度的和
    int res = 0;
    for (int i = 0; i < N; ++i)
        res += love[ match[i] ][i];
 
    return res;
}
 
int main()
{
    while (~scanf("%d", &N)) {
 
        for (int i = 0; i < N; ++i)
            for (int j = 0; j < N; ++j)
                scanf("%d", &love[i][j]);
 
        printf("%d\n", KM());
    }
    return 0;
}        
```



## 数据结构

### SPLY

除了一般平衡树的问题，sply可以处理一些线段问题

是一颗平衡二叉树，通过左旋右旋，在保证中序遍历的情况下，保证树高。核心，每操作一个节点，均将该节点旋转旋到树根

时时刻刻保证中序遍历是我们维护的序列的顺序。

sply(x,k):

对应四种情况：

左左型

左右型

右左型

右右型

考虑插入和删除

+ 将一个序列插入到y的后面：
  + 找到y的后继z
  + 可以想利用sply(y,0)将y旋转到根，将z旋转到y的下方，sply(z,y)
  + 由于z是大于y的第一个点，因此z的左子树一定为空，于是可以将要插入的序列全部插入到左子树中。
+ 删除一段序列L,R，可以找到L的左子节点，R的右子节点，可以将利用sply(L-1,0),sply(R+1,L-1)这一段序列全部放到了R-1的左子树上，直接删除即可。

sply 如何维护信息？

1)找到第K个数

+ size 每一颗子树的数量
+ 懒标记

pushup()利用两个儿子的信息，维护根节点的信息

pushdown()将懒标记下传:交换左右子树，然后懒标记下传,

trick：一般会为其增加哨兵。

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int n,m;
struct node
{
    int son[2],fa,valu;
    int size,flag;
    void init(int _v,int _p)
    {
        valu=_v;
        fa=_p;
        size=1;
    }
}tr[maxn];
int root,idx;
void pushup(int id)
{
    tr[id].size=tr[tr[id].son[0]].size+tr[tr[id].son[1]].size+1;
}
void pushdown(int id)
{
    if(tr[id].flag)
    {
        swap(tr[id].son[0],tr[id].son[1]);
        tr[tr[id].son[0]].flag^=1;
        tr[tr[id].son[1]].flag^=1;
        tr[id].flag=0;
    }
}
void rotate(int x)//四种旋转方式集于一身
{
    int y=tr[x].fa,z=tr[y].fa;
    int k=tr[y].son[1]==x;//k=0表示x是y的左儿子，k=1表示x是y的右儿子
    tr[z].son[tr[z].son[1]==y]=x,tr[x].fa=z;
    tr[y].son[k]=tr[x].son[k^1],tr[tr[x].son[k^1]].fa=y;
    tr[x].son[k^1]=y,tr[y].fa=x;
    pushup(y),pushup(x);
}
void splay(int x,int k)
{
    while(tr[x].fa!=k)
    {
        int y=tr[x].fa,z=tr[y].fa;
        if(z!=k)
            if((tr[y].son[1]==x)^(tr[z].son[1]==y))rotate(x);//如果不是在同一条链上的类型，即左左型或右右型，就需要先转一次。
            else rotate(y);
        rotate(x);
    }
    if(!k)root=x;//如果是转到根节点就需要变换根
}
void insert(int v)
{
    int u=root,fa=0;
    while(u)fa=u,u=tr[u].son[v>tr[u].valu];
    u=++idx;
    if(fa)tr[fa].son[v>tr[fa].valu]=u;
    tr[u].init(v,fa);
    splay(u,0);//之所以需要将其转换到根节点，一方面是为了pushup(),这要可以将插入点的信息对于整颗树更新，另一方面是为了降底期望时间复杂度。
}
int get_k(int k)
{
    int u=root;
    while(1)
    {
        pushdown(u);
        //printf("%d\n",u);
        if(tr[tr[u].son[0]].size>=k)u=tr[u].son[0];
        else if(tr[tr[u].son[0]].size+1==k)return u;
        else k-=(tr[tr[u].son[0]].size+1),u=tr[u].son[1];
    }
    return -1;
}
void output(int u)
{
    pushdown(u);
    if(tr[u].son[0])output(tr[u].son[0]);
    if(tr[u].valu>=1&&tr[u].valu<=n)printf("%d ",tr[u].valu);
    if(tr[u].son[1])output(tr[u].son[1]);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<=n+1;i++)insert(i);//增加两个哨兵。
	while(m--)
    {
    	
        int l,r;
        scanf("%d%d",&l,&r);
        l=get_k(l),r=get_k(r+2);//由于增加了哨兵,所以不管左右都需要+1.
        //printf("find:\n");
		splay(l,0);splay(r,l);
        tr[tr[r].son[0]].flag^=1;//将r的左子树内的数全部翻转。
    }
    output(root);
    return 0;
}
```

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int n,mi;
struct node
{
    int son[2],size,fa,value;
    void init(int _v,int _fa)
    {
        fa=_fa,value=_v;
        size=1;
    }
}tr[maxn];
int root,idx,add=0;
void pushup(int x)
{
    tr[x].size = tr[tr[x].son[0]].size+tr[tr[x].son[1]].size+1;
}
void rotate(int x)//四种旋转方式集于一身
{
    int y=tr[x].fa,z=tr[y].fa;
    int k=tr[y].son[1]==x;//k=0表示x是y的左儿子，k=1表示x是y的右儿子
    tr[z].son[tr[z].son[1]==y]=x,tr[x].fa=z;
    tr[y].son[k]=tr[x].son[k^1],tr[tr[x].son[k^1]].fa=y;
    tr[x].son[k^1]=y,tr[y].fa=x;
    pushup(y),pushup(x);
}
void splay(int x,int k)
{
    while(tr[x].fa!=k)
    {
        int y=tr[x].fa,z=tr[y].fa;
        if(z!=k)
            if((tr[y].son[1]==x)^(tr[z].son[1]==y))rotate(x);//如果不是在同一条链上的类型，即左左型或右右型，就需要先转一次。
            else rotate(y);
        rotate(x);
    }
    if(!k)root=x;//如果是转到根节点就需要变换根
}

int insert(int x)
{
    int u=root,fa=0;
    while(u)fa=u,u=tr[u].son[x>tr[u].value];
    u=++idx;
    if(fa)tr[fa].son[x>tr[fa].value]=u;
    tr[u].init(x,fa);
    splay(u,0);
	return u;
}
int get_mid(int x)
{
    int u=root,ans=0;
    while(u)
    {
        if(tr[u].value>=x)ans=u,u=tr[u].son[0];
        else u=tr[u].son[1];
    }
    return ans;
}
int get_k(int k)
{
    
    int u=root;
    while(1)
    {
        if(tr[tr[u].son[0]].size>=k)u=tr[u].son[0];
        else if(tr[tr[u].son[0]].size+1==k)return tr[u].value;
        else k-=tr[tr[u].son[0]].size+1,u=tr[u].son[1];
    }
    return -1;
}
int main()
{
    scanf("%d%d",&n,&mi);
    char op[2];
    int L=insert(-1e9),R=insert(1e9);
    int cnt=0;
    for(int i=1;i<=n;i++)
    {
        int k;
        scanf("%s%d",op,&k);
        if(op[0]=='I')
        {
            if(k<mi)continue;
            k-=add;
            insert(k);
        }
        else if(op[0]=='A')
        {
            add+=k;
        }
        else if(op[0]=='S')
        {
            add-=k;
            int r=get_mid(mi-add);
            if(tr[r].value+add<mi)r=R;
            splay(L,0);splay(r,L);
            cnt+=tr[tr[r].son[0]].size;
            tr[r].son[0]=0;
            pushup(r),pushup(L);
        }
        else 
        {
            if(k>tr[root].size-2)printf("-1\n");
            else printf("%d\n",get_k(tr[root].size-2-k+1+1)+add);
        }
    }
    printf("%d\n",cnt);
    return 0;
}
```

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1800010;

int n, m;
struct Node
{
    int s[2], p, v, id;
    int size;

    void init(int _v, int _id, int _p)
    {
        v = _v, id = _id, p = _p;
        size = 1;
    }
}tr[N];
int root[N], idx;
int p[N];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void pushup(int x)
{
    tr[x].size = tr[tr[x].s[0]].size + tr[tr[x].s[1]].size + 1;
}

void rotate(int x)
{
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}

void splay(int x, int k, int b)
{
    while (tr[x].p != k)
    {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        rotate(x);
    }
    if (!k) root[b] = x;
}

void insert(int v, int id, int b)
{
    int u = root[b], p = 0;
    while (u) p = u, u = tr[u].s[v > tr[u].v];
    u = ++ idx;
    if (p) tr[p].s[v > tr[p].v] = u;
    tr[u].init(v, id, p);
    splay(u, 0, b);
}

int get_k(int k, int b)
{
    int u = root[b];
    while (u)
    {
        if (tr[tr[u].s[0]].size >= k) u = tr[u].s[0];
        else if (tr[tr[u].s[0]].size + 1 == k) return tr[u].id;
        else k -= tr[tr[u].s[0]].size + 1, u = tr[u].s[1];
    }
    return -1;
}

void dfs(int u, int b)
{
    if (tr[u].s[0]) dfs(tr[u].s[0], b);
    if (tr[u].s[1]) dfs(tr[u].s[1], b);
    insert(tr[u].v, tr[u].id, b);
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = root[i] = i;
        int v;
        scanf("%d", &v);
        tr[i].init(v, i, 0);
    }
    idx = n;

    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        a = find(a), b = find(b);
        if (a != b)
        {
            if (tr[root[a]].size > tr[root[b]].size) swap(a, b);
            dfs(root[a], b);
            p[a] = b;
        }
    }

    scanf("%d", &m);
    while (m -- )
    {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        if (*op == 'B')
        {
            a = find(a), b = find(b);
            if (a != b)
            {
                if (tr[root[a]].size > tr[root[b]].size) swap(a, b);
                dfs(root[a], b);
                p[a] = b;
            }
        }
        else
        {
            a = find(a);
            if (tr[root[a]].size < b) puts("-1");
            else printf("%d\n", get_k(b, a));
        }
    }

    return 0;
}
```



### 朴素暴力的升级--分块

分块的思想是将其分成多段，然后基于操作维护信息。

以根号分块为例

需要考虑如何维护完整段和分散段的信息

+ 完整段
+ 起始段和结束段

分块需要计算好时间复杂度

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
#define ll long long
const int maxn=1e5+5;
const int maxm=350;
int n,m,len;
ll sum[maxm],addi[maxm];
int a[maxn];
int get(int id)
{
    return id/len;
}
void update(int l,int r,int d)
{
    if(get(l)==get(r))
    {
        for(int i=l;i<=r;i++)
        {
            a[i]+=d;
            sum[get(i)]+=d;
        }
        return ;
    }
    int i=l,j=r;
    while(get(i)==get(l))a[i]+=d,sum[get(i)]+=d,i++;
    while(get(j)==get(r))a[j]+=d,sum[get(j)]+=d,j--;
    for(int k=get(i);k<=get(j);k++)
    {
        sum[k]+=len*d,addi[k]+=d;
    }
}
ll ask(int l,int r)
{
    ll res=0;
    if(get(l)==get(r))
    {
        for(int i=l;i<=r;i++)
        {
            res+=a[i]+addi[get(i)];
        }
    }
    else 
    {
        int i=l,j=r;
        while(get(i)==get(l))res+=a[i]+addi[get(i)],i++;
        while(get(j)==get(r))res+=a[j]+addi[get(j)],j--;
        for(int k=get(i);k<=get(j);k++)
        {
            res+=sum[k];
        }
    }
    return res;
}
void solve()
{
    scanf("%d %d",&n,&m);
    len=sqrt(n);    
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),sum[get(i)]+=a[i];
    char op[2];
    int l,r,d;
    while(m--)
    {
        scanf("%s",op);
        if(*op=='Q')
        {
            scanf("%d%d",&l,&r);
            printf("%lld\n",ask(l,r));
        }
        else 
        {
            scanf("%d%d%d",&l,&r,&d);
            update(l,r,d);            
        }
    }
}
int main()
{
    int t=1;
    while(t--)solve();
    return 0;
}
```

#### 块状链表

块状链表是以链表的形式来连接各个块

有以下三种操作:

+ 插入一段
  + 分裂结点   O(1)
  + 插入一个序列 O(g n)

+ 删除一段：
  + 删除kai头节点的后半部分O(g n)
  + 删除中间完整结点 O(g n)
  + 删除结尾节点的前半部分 O(g n)
+ 合并：遍历整个链表，若下一个结点可以合并当前节点则何必 ，自己定义一个规则，比如总结点数大于4 g n .

 ```c++
 #include <iostream>
 #include <cstdio>
 #include <cstring>
 #include <algorithm>
 
 using namespace std;
 
 const int N = 2000, M = 2010;
 
 int n, x, y;
 struct Node
 {
     char s[N + 1];
     int c, l, r;
 }p[M];
 char str[2000010];
 int q[M], tt;  // 内存回收
 
 void move(int k)  // 移到第k个字符后面
 {
     x = p[0].r;
     while (k > p[x].c) k -= p[x].c, x = p[x].r;
     y = k - 1;
 }
 
 void add(int x, int u)  // 将节点u插到节点x的右边
 {
     p[u].r = p[x].r, p[p[u].r].l = u;
     p[x].r = u, p[u].l = x;
 }
 
 void del(int u)  // 删除节点u
 {
     p[p[u].l].r = p[u].r;
     p[p[u].r].l = p[u].l;
     p[u].l = p[u].r = p[u].c = 0;  // 清空节点u
     q[ ++ tt] = u;  // 回收节点u
 }
 
 void insert(int k)  // 在光标后插入k个字符
 {
     if (y < p[x].c - 1)  // 从光标处分裂
     {
         int u = q[tt -- ];  // 新建一个节点
         for (int i = y + 1; i < p[x].c; i ++ )
             p[u].s[p[u].c ++ ] = p[x].s[i];
         p[x].c = y + 1;
         add(x, u);
     }
     int cur = x;
     for (int i = 0; i < k;)
     {
         int u = q[tt -- ];  // 创建一个新的块
         while (p[u].c < N && i < k)
             p[u].s[p[u].c ++ ] = str[i ++ ];
         add(cur, u);
         cur = u;
     }
 }
 
 void remove(int k)  // 删除光标后的k个字符
 {
     if (p[x].c - 1 - y >= k)  // 节点内删
     {
         for (int i = y + k + 1, j = y + 1; i < p[x].c; i ++, j ++ ) p[x].s[j] = p[x].s[i];
         p[x].c -= k;
     }
     else
     {
         k -= p[x].c - y - 1;  // 删除当前节点的剩余部分
         p[x].c = y + 1;
         while (p[x].r && k >= p[p[x].r].c)
         {
             int u = p[x].r;
             k -= p[u].c;
             del(u);
         }
         int u = p[x].r;  // 删除结尾节点的前半部分
         for (int i = 0, j = k; j < p[u].c; i ++, j ++ ) p[u].s[i] = p[u].s[j];
         p[u].c -= k;
     }
 }
 
 void get(int k)  // 返回从光标开始的k个字符
 {
     if (p[x].c - 1 - y >= k)  // 节点内返回
     {
         for (int i = 0, j = y + 1; i < k; i ++, j ++ ) putchar(p[x].s[j]);
     }
     else
     {
         k -= p[x].c - y - 1;
         for (int i = y + 1; i < p[x].c; i ++ ) putchar(p[x].s[i]);  // 输出当前节点的剩余部分
         int cur = x;
         while (p[cur].r && k >= p[p[cur].r].c)
         {
             int u = p[cur].r;
             for (int i = 0; i < p[u].c; i ++ ) putchar(p[u].s[i]);
             k -= p[u].c;
             cur = u;
         }
         int u = p[cur].r;
         for (int i = 0; i < k; i ++ ) putchar(p[u].s[i]);
     }
     puts("");
 }
 
 void prev()  // 光标向前移动一位
 {
     if (!y)
     {
         x = p[x].l;
         y = p[x].c - 1;
     }
     else y -- ;
 }
 
 void next()  // 光标向后移动一位
 {
     if (y < p[x].c - 1) y ++ ;
     else
     {
         x = p[x].r;
         y = 0;
     }
 }
 
 void merge()  // 将长度较短的相邻节点合并，保证块状链表时间复杂度的核心
 {
     for (int i = p[0].r; i; i = p[i].r)
     {
         while (p[i].r && p[i].c + p[p[i].r].c < N)
         {
             int r = p[i].r;
             for (int j = p[i].c, k = 0; k < p[r].c; j ++, k ++ )
                 p[i].s[j] = p[r].s[k];
             if (x == r) x = i, y += p[i].c;  // 更新光标的位置
             p[i].c += p[r].c;
             del(r);
         }
     }
 }
 
 int main()
 {
     for (int i = 1; i < M; i ++ ) q[ ++ tt] = i;
     scanf("%d", &n);
     char op[10];
 
     str[0] = '>';
     insert(1);  // 插入哨兵
     move(1);  // 将光标移动到哨兵后面
 
     while (n -- )
     {
         int a;
         scanf("%s", op);
         if (!strcmp(op, "Move"))
         {
             scanf("%d", &a);
             move(a + 1);
         }
         else if (!strcmp(op, "Insert"))
         {
             scanf("%d", &a);
             int i = 0, k = a;
             while (a)
             {
                 str[i] = getchar();
                 if (str[i] >= 32 && str[i] <= 126) i ++, a -- ;
             }
             insert(k);
             merge();
         }
         else if (!strcmp(op, "Delete"))
         {
             scanf("%d", &a);
             remove(a);
             merge();
         }
         else if (!strcmp(op, "Get"))
         {
             scanf("%d", &a);
             get(a);
         }
         else if (!strcmp(op, "Prev")) prev();
         else next();
     }
 
     return 0;
 }
 ```



### kruskal重构树

kruskal重构树的性质：
1 、 根 据 我 们 构 造 的 过 程 ， 这 是 一 个 二 叉 堆 1、根据我们构造的过程，这是一个二叉堆1、根据我们构造的过程，这是一个二叉堆
2 、 原 树 两 点 之 间 的 边 权 最 大 值 是 重 构 树 上 两 点 l c a 的 权 值 2、原树两点之间的边权最大值是重构树上两点lca的权值2、原树两点之间的边权最大值是重构树上两点lca的权值
3 、 重 构 树 中 代 表 原 树 中 的 点 的 节 点 全 是 叶 子 节 点 ， 其 余 节 点 都 代 表 了 一 条 边 的 边 权 。 3、重构树中代表原树中的点的节点全是叶子节点，其余节点都代表了一条边的边权。3、重构树中代表原树中的点的节点全是叶子节点，其余节点都代表了一条边的边权。

对kruskal重构树有了基本的了解之后，我们接着往后看。

首 先 我 们 可 以 先 求 出 所 给 图 的 k r u s k a l 重 构 树 ， 然 后 d f s 求 出 树 的 l c a 倍 增 数 组 （ 根 据 重 构 树 的 性 质 我 们 可 以 发 现 ， 首先我们可以先求出所给图的kruskal重构树，然后dfs求出树的lca倍增数组（根据重构树的性质我们可以发现，首先我们可以先求出所给图的kruskal重构树，然后dfs求出树的lca倍增数组（根据重构树的性质我们可以发现，k r u s k a l 重 构 树 和 l c a 基 本 上 都 是 一 起 用 的 ） 。 此 外 ， 在 d f s 的 过 程 中 ， 我 们 让 n w [ u ] = 以 u 为 根 的 子 树 中 所 有 点 的 kruskal重构树和lca基本上都是一起用的）。此外，在dfs的过程中，我们让nw[u]=以u为根的子树中所有点的kruskal重构树和lca基本上都是一起用的）。此外，在dfs的过程中，我们让nw[u]=以u为根的子树中所有点的点 权 和 （ 原 图 的 点 ） 点权和（原图的点）点权和（原图的点）

做 完 前 面 的 准 备 之 后 ， 我 们 来 正 式 处 理 每 个 查 询 。 做完前面的准备之后，我们来正式处理每个查询。做完前面的准备之后，我们来正式处理每个查询。

对 于 一 个 查 询 ： u ( 起 点 ) 和 s ( 初 始 值 ) 。 对于一个查询：u(起点)和s(初始值)。对于一个查询：u(起点)和s(初始值)。
我 们 从 起 点 u 开 始 往 上 跳 ， 如 果 该 位 置 的 点 权 （ 树 上 的 点 权 为 这 棵 子 树 内 所 有 实 点 的 边 权 最 大 值 ） 小 于 我 们 当 前 我们从起点u开始往上跳，如果该位置的点权（树上的点权为这棵子树内所有实点的边权最大值）小于我们当前我们从起点u开始往上跳，如果该位置的点权（树上的点权为这棵子树内所有实点的边权最大值）小于我们当前能 量 数 （ 实 点 权 和 + 初 始 值 ） ， 就 跳 过 去 ， 同 时 更 新 能 量 数 （ 新 树 上 的 实 点 权 和 + 初 始 值 ） 。 再 继 续 看 能 不 能量数（实点权和+初始值），就跳过去，同时更新能量数（新树上的实点权和+初始值）。再继续看能不能量数（实点权和+初始值），就跳过去，同时更新能量数（新树上的实点权和+初始值）。再继续看能不能 往 上 跳 … … 一 直 到 不 能 再 往 上 跳 了 为 止 （ 因 为 是 通 过 倍 增 法 向 上 跳 的 ， 所 以 单 次 查 找 的 复 杂 度 只 有 l o g 2 n ） 能往上跳……一直到不能再往上跳了为止（因为是通过倍增法向上跳的，所以单次查找的复杂度只有log_2n）能往上跳……一直到不能再往上跳了为止（因为是通过倍增法向上跳的，所以单次查找的复杂度只有log 2n

```c++
#include <iostream>
#include <cstdio>
#include <cmath>
#include <string>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <vector>
#include <algorithm>
#include <iomanip>
#define LL long long
#define ULL unsigned long long
#define PII pair<int,int>
#define PLL pair<LL,LL>
#define PDD pair<double,double>
#define x first
#define y second
using namespace std;
const int N=2e5+5,mod=998244353;
struct Edge{				//边集
	int u,v,w;
	bool operator< (const Edge e)const
	{ return w<e.w; }
}e[N];
vector<int> h[N];
LL nw[N],st[N];			//nw[]记录实体图的点权，st[]记录实体图的边权
int p[N],f[N][20];		//f[][]为倍增法lca的fa数组
int find(int x)			//并查集模板
{
	if(p[x]!=x) p[x]=find(p[x]);
	return p[x];
}
int kruskal(int n,int m)		//求kruskal重构树的模板
{
	int cnt=n;
	sort(e,e+m);				//对边排序
	for(int i=0;i<m;i++)		//枚举边
	{
		int u=find(e[i].u),v=find(e[i].v),w=e[i].w;
		if(u!=v)			//如果u-v不连通，则连一条边
		{
			st[++cnt]=w;					//新建一个点，点权为u-v边权w
			p[cnt]=p[u]=p[v]=cnt;			//将根节点置为新点（保证所以实点都为叶节点）
			h[u].push_back(cnt);			//连边
			h[v].push_back(cnt);
			h[cnt].push_back(u);
			h[cnt].push_back(v);
		}
	}
	return cnt;
}
void dfs(int u,int fa)		//求lca的倍增数组
{
	f[u][0]=fa;
	for(int i=1;i<20;i++) f[u][i]=f[f[u][i-1]][i-1];
	for(int v:h[u])
	{
		if(v==fa) continue;
		dfs(v,u);
		nw[u]+=nw[v];		//nw[u]更新为以u为根的子树内所以实点的点权和
	}
}
int main()
{
	cin.tie(0);
	ios::sync_with_stdio(false);
	int n,m,q;
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++) p[i]=i;
	for(int i=1;i<=n;i++) cin>>nw[i];
	for(int i=0;i<m;i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		e[i]={a,b,c};
	}
	n=kruskal(n,m);			//建立重构树，跟新n的大小
	dfs(n,0);				//预处理需要的数组
	st[0]=1e18;				//防止u节点跳过根节点
	while(q--)
	{
		int u,s;
		cin>>u>>s;
		LL ans=nw[u]+s;		//初始化能量数
		while(u!=n)
		{
			int t=u;
			for(int i=19;i>=0;i--)		//只要能往上跳就往上跳（需要能量数>这部分的最大边权）
				if(st[f[u][i]]<=ans) u=f[u][i];
			if(t==u) break;			//如果这一轮没有往上跳，说明不能再往上跳了（退出）
			ans=nw[u]+s;		//更新答案
		}
		cout<<ans<<"\n";
	}
	return 0;
}

```



### 莫队--优雅的暴力

当遇到大量的区间询问时，假如区间的左右下标有着一定的规律，我们可以如何求解？

如：

$[1,3],[1,4],[1,5],[2,5]$。

当然是双指针！其时间复杂度从$n^2$下降到$o(n)$。

莫队就是这样一个算法，通过预处理询问顺序，来降低时间复杂度，当然，前提是能够预处理，强制在线的题目便与莫队无缘。

其预处理流程如下：

+ 首先将数据分块，分块大小为size
+ 将区间排序，如果区间的左端点落在同一个块中，那么我们将其按右端点大小排序。
+ 如果它们的左端点不在同一块中，那么便按照左端点升序排序。

当我们处理完区间顺序之后，剩下的就是之后双指针的左右移动罢了，考虑增加和删除对与答案的影响，也就结束了。

```cpp
ll sum = 0;
	s[a[1]]++;
	for (int i = 1; i <= m; i++)
	{
		while (l < q[i].l)sum += del(l++);
		while (l > q[i].l)sum += add(--l);
		while (r < q[i].r)sum += add(++r);
		while (r > q[i].r)sum += del(r--);
		ans[q[i].id] = sum;
	}
```

那么问题来了，如何分析莫队算法的时间复杂度呢？

考虑对单一块进行询问，我们考虑最糟糕的情况，同一块中的左端点再反复横跳，先是再块的最左端，然后跑到最右端如此反复，当然，右端点是有序的，它只会后移操作。那么其实时间复杂度为$o(\sqrt{size}*m_i+n)$，其中$m_i$表示再第i块中的区间数.

那么对于总体的时间复杂度为$o(\sqrt{size}*m+n*(\frac{n}{size}))$​。

[洛谷P1494](https://www.luogu.com.cn/problem/P1494)

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn = 5e4 + 5;
struct node {
	int l, r, id;
}q[maxn];
ll n, m, a[maxn], ans[maxn], l = 1, r = 1, sum, s[maxn], id[maxn], Size;
ll lef[maxn], righ[maxn];
bool cmp(struct node x, struct node y)
{
	if (id[x.l] == id[y.l])
	{
		if(id[x.l]&1)return x.r < y.r;
		return x.r>y.r;
	}//排序，左端点在同一块内，按右区间升序排序 ,奇数偶数优化
	return x.l < y.l;//否则，按左区间排序 
}
ll add(int x)
{
	ll gs = ++s[a[x]];
	return s[a[x]] * (s[a[x]] - 1) / 2 - (s[a[x]] - 1)*(s[a[x]] - 2) / 2;//返回影响
}
ll del(int x)
{
	ll gs = --s[a[x]];
	return gs * (gs - 1) / 2 - gs * (gs + 1) / 2;//返回影响
}
ll gcd(ll a, ll b)
{
	if (a == 0)return b>0?b:1;
	return b == 0 ? a : gcd(b, a%b);
}
int main()
{
	ios::sync_with_stdio(false);
	//freopen("P1494_1.in", "r+", stdin);
	cin >> n >> m;
	Size = n / sqrt(m * 2 / 3);//分块大小，会影响时间复杂度。
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
		id[i] = (i - 1) / Size + 1;
	}
	for (int i = 1; i <= m; i++)
	{
		cin >> q[i].l >> q[i].r;
		q[i].id = i;
		lef[i] = q[i].l;
		righ[i] = q[i].r;
	}
	sort(q + 1, q + m + 1, cmp);
	ll sum = 0;
	s[a[1]]++;
	for (int i = 1; i <= m; i++)
	{
		while (l < q[i].l)sum += del(l++);
		while (l > q[i].l)sum += add(--l);
		while (r < q[i].r)sum += add(++r);
		while (r > q[i].r)sum += del(r--);
		ans[q[i].id] = sum;
	}
	//cout << m << endl;
	for (int i = 1; i <= m; i++)
	{
		ll gs = righ[i] - lef[i] + 1;
		if (gs == 1) { cout << "0/1" << endl; continue; }
		ll g=gcd(ans[i], gs*(gs - 1) / 2);
		//cout <<i<<" "<< ans[i]<<" "<<g << endl;
		cout<<  ans[i] / g << '/' << gs * (gs - 1) / 2 / g << endl;
	}
	return 0;
}
```

[codeforces](https://codeforces.com/contest/617/problem/E)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6+6;
#define ll long long
ll a[maxn],cnt=0,buc1[maxn],buc2[maxn],id[maxn],ans[maxn];
int Size;
struct mo
{
	int l,r;
	int pos;
	bool operator <(const struct mo x)const
	{
		if(id[l]==id[x.l])
        {
            if(id[l]&1)return r<x.r;
            return r>x.r;
        }
		return l<x.l;
	}
}q[maxn];
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	Size=(int)sqrt(n);
	for(int i=1;i<=n;i++)
	{
		//cin>>a[i];
		scanf("%lld",&a[i]);
		a[i]^=a[i-1];
		id[i]=(i-1)/Size+1;
	}
	//for(int i=1;i<=n;i++)cout<<a[i]<<" ";cout<<endl;
	for(int i=1;i<=m;i++)
	{
		//cin>>q[i].l>>q[i].r;
		scanf("%lld%lld",&q[i].l,&q[i].r);
		q[i].pos=i;
	}
	sort(q+1,q+m+1);
	ll l=1,r=1,cnt=0;
	buc1[0]=1;
	buc2[a[1]]=1;
	if(a[1]==k)cnt++;
	for(int i=1;i<=m;i++)
	{
		//cout<<q[i].pos<<endl; 
		while(r<q[i].r)
		{	
			buc1[a[r]]++;buc2[a[r+1]]++;
			cnt+=buc1[a[r+1]^k];
		//	if(buc1[a[r+1]^k]>0)cout<<i<<" "<<l<<" "<<r+1<<" +"<<buc1[a[r+1]^k]<<endl;
			r++;
			
		}
		while(r>q[i].r)
		{	
			
			cnt-=buc1[a[r]^k];
		//	if(buc1[a[r]^k]>0)cout<<i<<" "<<l<<" "<<r-1<<" -"<<buc1[a[r]^k]<<endl;
			buc1[a[r-1]]--;buc2[a[r]]--;
			r--;
		}
		while(l<q[i].l)
		{
			cnt-=buc2[a[l-1]^k];
		//	if(buc2[a[l-1]^k]>0)cout<<i<<" "<<l+1<<" "<<r<<" -"<<buc2[a[l-1]^k]<<endl;
			buc1[a[l-1]]--;buc2[a[l]]--;
			l++;
		}
		while(l>q[i].l)
		{	
			buc2[a[l-1]]++;
			cnt+=buc2[a[l-2]^k];
		//	if(buc2[a[l-2]^k]>0)cout<<i<<" "<<l-1<<" "<<r<<" +"<<buc2[a[l-2]^k]<<endl;
			l--;
			buc1[a[l-1]]++;
		}
		ans[q[i].pos]=cnt;
	}
	for(int i=1;i<=m;i++)printf("%lld\n",ans[i]);
	return 0;
}
```

2021牛客国庆

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=2e6+6;
#define scf(x) scanf("%d",&x)
int pos[maxn],a[maxn],Size,buc[maxn],cnt,ans[maxn];
struct mo
{
    int l,r;
    int id;
    bool operator <(const struct mo y)const
    {
        if(pos[l]==pos[y.l])
        {
            if(pos[l]&1)return r<y.r;
            return r>y.r;                
        }
        return l<y.l;
    }
}q[maxn];
inline void add(int x)
{
    if(buc[a[x]]==0)cnt++;
    buc[a[x]]++;
}
inline void del(int x)
{
    if(buc[a[x]]==1&&x!=0)cnt--;
    buc[a[x]]--;
}
int main()
{
    int n,m;
    while(~scanf("%d %d",&n,&m)){
        Size=sqrt(n);
        cnt=0;
        for(int i=1;i<=n;i++)scf(a[i]),pos[i]=(i-1)/Size+1,buc[i]=0;
        for(int i=1;i<=n;i++)
        {
            if(buc[a[i]]==0)cnt++;
            buc[a[i]]++;
        }
       // cout<<cnt<<endl;
        for(int i=1;i<=m;i++)scf(q[i].l),scf(q[i].r),q[i].id=i;
        sort(q+1,q+m+1);
        int l=0,r=0;
        for(int i=1;i<=m;i++)
        {
            while(r<q[i].r)del(r++);
            while(r>q[i].r)add(--r);
            while(l<q[i].l)add(++l);
            while(l>q[i].l)del(l--);
            ans[q[i].id]=cnt;
        }
        for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
    }
    return 0;
}
```

#### 莫队进阶--带修莫队

 由于需要修改，因此不能再简单的移动的左右指针，还需要增加一维的信息(时间维度)，

![image-20220722214258754](D:\none_c\ACM\待修莫队.png)

细节:时间指针可以往上走，也可以往下走，取巧写法，将要操作的数和操作中的数swap。

如何排序？

+ l的所在块的编号
+ r的所在的编号
+ t

需要计算快的大小。

y总分析方法:

首先计算O(l),O(t),O(r);

然后理性分析一下。

y总建议$O(g3 n*t)$, 网友建议O(g3 n^2),如果这两个都不行，那就自己算算吧。

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=1e4+5;
const int maxs=1e6+1;
int n,m,len,mc,mq;
int w[maxn],cnt[maxs],ans[maxn];
struct Query
{
    int id,l,r,t;
}q[maxn];

struct Modify
{
    int p,c;
}c[maxn];
int get(int x)
{
    return x/len;
}
bool cmp(const Query& a,const Query& b)
{
    int al=get(a.l),ar=get(a.r);
    int bl=get(b.l),br=get(b.r);
    if(al!=bl)return al<bl;
    if(ar!=br)return ar<br;
    return a.t<b.t;
}
void add(int x,int&res)
{
    if(!cnt[x])res++;
    cnt[x]++;
}
void del(int x,int&res){
    cnt[x]--;
    if(cnt[x]==0)res--;
}
int  main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&w[i]);
    char op[2];int a,b;
    for(int i=1;i<=m;i++)
    {
        scanf("%s%d%d",op,&a,&b);
        if(*op=='Q')mq++,q[mq]={mq,a,b,mc};
        else c[++mc]={a,b};
    }
    len = cbrt((double)n*max(1,mc))+1;//求开三次方，+1防止为0,max防止修改0;
    sort(q+1,q+mq+1,cmp);
    int res=0;
    for(int i=0,j=1,t=0,k=1;k<=mq;k++)
    {
        int id=q[k].id,l=q[k].l,r=q[k].r,tm=q[k].t;
        while(i<r)add(w[++i],res);
        while(i>r)del(w[i--],res);
        while(j<l)del(w[j++],res);
        while(j>l)add(w[--j],res);
        while(t<tm)
        {
            t++;
            if(c[t].p>=j&&c[t].p<=i)
            {
                del(w[c[t].p],res);
                add(c[t].c,res);
            }
            swap(w[c[t].p],c[t].c);
        }
        while(t>tm)
        {
            if(c[t].p>=j&&c[t].p<=i)
            {
                del(w[c[t].p],res);
                add(c[t].c,res);
            }
            swap(w[c[t].p],c[t].c);
            t--;
        }
        ans[id]=res;
    }
    for(int i=1;i<=mq;i++)printf("%d\n",ans[i]);
    return 0;
}
```

#### 莫队进阶二--回滚莫队

回滚莫队应用：当我们发现莫队的插入比较容易即 o(1),但删除比较难维护时使用回滚莫队

排序同上，当l,r在同一个块中时，采用暴力算法求解

将需要维护的分为两个部分一个左部，一个右部，左边小于根号n，故左边采用暴力方法是的端点到达右端点，右边由于只会递增，故只需要维护插入操作,需要记录右部答案，在施行完左部分后可以恢复。

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=1e5+5;
vector<ll>nums;
int n,m,len;
ll w[maxn],ans[maxn],cnt[maxn];
int get(int x)
{
    return x/len;
}
struct Querry
{
    int id,l,r;
    bool operator < (Querry &x)const 
    {
        int il=get(l),ir=get(x.l);
        if(il!=ir)return il<ir;
        return r<x.r;
    } 
}q[maxn];
void add(int x,ll &res)		
{
    cnt[x]++;
    res=max(res,(ll)cnt[x]*nums[x]);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%lld",&w[i]),nums.push_back(w[i]);
    sort(nums.begin(),nums.end());
    nums.resize(unique(nums.begin(),nums.end())-nums.begin());
    for(int i=1;i<=n;i++)w[i]=lower_bound(nums.begin(),nums.end(),w[i])-nums.begin();
    len = sqrt(n);
    for(int i=1;i<=m;i++)
    {
        int id,l,r;
        scanf("%d%d",&l,&r);
        q[i]={i,l,r};
    }
    sort(q+1,q+m+1);
    //for(int i=1;i<=m;i++)printf("find:%d\n",q[i].id);

    for(int x=1;x<=m;)
    {
        int y=x;
        int right=get(q[x].l)*len+len-1;
        while(y<=m&&get(q[y].l)==get(q[x].l))y++;
        //printf("%d %d %d %d\n",x,y,get(q[x].l),get(q[x].r));
        while(x<y&&q[x].r<=right)
        {   
            ll res=0;
            int id=q[x].id,l=q[x].l,r=q[x].r;
            for(int i=l;i<=r;i++)add(w[i],res);
            ans[id]=res;
            for(int i=l;i<=r;i++)cnt[w[i]]--;
            //printf("find1:%d\n",x);
            x++;
        }
        int  i,j=0;
        i=right+1,j=right;//i从当前块的最后一个开始，j从下一个块的起点开始
        ll res=0;
        while(x<y)
        {
            int id=q[x].id,l=q[x].l,r=q[x].r;
            while(j<r)add(w[++j],res);
            ll temp=res;
            while(i>l)add(w[--i],res);
            ans[id]=res;
            while(i<right+1)cnt[w[i++]]--;
            res=temp;
            //printf("find2:%d\n",x);
            x++;
        }
        memset(cnt,0,sizeof cnt);
    }
    for(int i=1;i<=m;i++)printf("%lld\n",ans[i]);
    return 0;

}
```

#### 莫队进阶三---树上莫队

将树用dfs序，对dfs序进行遍历。

```c++
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <vector>

using namespace std;

const int N = 100010;

int n, m, len;
int w[N];
int h[N], e[N], ne[N], idx;
int depth[N], f[N][16];
int seq[N], top, first[N], last[N];
int cnt[N], st[N], ans[N];
int que[N];
struct Query
{
    int id, l, r, p;
}q[N];
vector<int> nums;

void add_edge(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u, int father)
{
    seq[ ++ top] = u;
    first[u] = top;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j != father) dfs(j, u);
    }
    seq[ ++ top] = u;
    last[u] = top;
}

void bfs()
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[1] = 1;
    int hh = 0, tt = 0;
    que[0] = 1;
    while (hh <= tt)
    {
        int t = que[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] > depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                f[j][0] = t;
                for (int k = 1; k <= 15; k ++ )
                    f[j][k] = f[f[j][k - 1]][k - 1];
                que[ ++ tt] = j;
            }
        }
    }
}

int lca(int a, int b)
{
    if (depth[a] < depth[b]) swap(a, b);
    for (int k = 15; k >= 0; k -- )
        if (depth[f[a][k]] >= depth[b])
            a = f[a][k];
    if (a == b) return a;
    for (int k = 15; k >= 0; k -- )
        if (f[a][k] != f[b][k])
        {
            a = f[a][k];
            b = f[b][k];
        }
    return f[a][0];
}

int get(int x)
{
    return x / len;
}

bool cmp(const Query& a, const Query& b)
{
    int i = get(a.l), j = get(b.l);
    if (i != j) return i < j;
    return a.r < b.r;
}

void add(int x, int& res)
{
    st[x] ^= 1;
    if (st[x] == 0)
    {
        cnt[w[x]] -- ;
        if (!cnt[w[x]]) res -- ;
    }
    else
    {
        if (!cnt[w[x]]) res ++ ;
        cnt[w[x]] ++ ;
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]), nums.push_back(w[i]);
    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());
    for (int i = 1; i <= n; i ++ )
        w[i] = lower_bound(nums.begin(), nums.end(), w[i]) - nums.begin();

    memset(h, -1, sizeof h);
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add_edge(a, b), add_edge(b, a);
    }

    dfs(1, -1);
    bfs();

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        if (first[a] > first[b]) swap(a, b);
        int p = lca(a, b);
        if (a == p) q[i] = {i, first[a], first[b]};
        else q[i] = {i, last[a], first[b], p};
    }

    len = sqrt(top);
    sort(q, q + m, cmp);

    for (int i = 0, L = 1, R = 0, res = 0; i < m; i ++ )
    {
        int id = q[i].id, l = q[i].l, r = q[i].r, p = q[i].p;
        while (R < r) add(seq[ ++ R], res);
        while (R > r) add(seq[R -- ], res);
        while (L < l) add(seq[L ++ ], res);
        while (L > l) add(seq[ -- L], res);
        if (p) add(p, res);
        ans[id] = res;
        if (p) add(p, res);
    }

    for (int i = 0; i < m; i ++ ) printf("%d\n", ans[i]);

    return 0;
}
```

#### dfs序

记录dfs时出栈和进栈的时间，通过记录下dfs序可以将其转换为dfs序，再利用各种数据结构来进行区间操作。

dfs获得dfs序

```
int r[maxn],c[maxn];
void dfs(int s,int fa)
{
	r[s]=++dfn;
	for(aotu it: v)
	{
		if()
	}
	c[s]=dfn;
}
```



性质：

判断两点是否在同一个根->叶上，即两点的区间是否有交集。

1. 任意子树都是连续的。例如假设有个子树BEFKBEFK，在序列中对应的部分是：BEEFKKFBBEEFKKFB；子树CGHICGHI，在序列中对应的部分是：CGGHHIICCGGHHIIC。
2. 任意点对(a,b)之间的路径，可分为两种情况，首先是令lca是a、ba、b的最近公共祖先：
   1.若lcalca是a、b之一，则a、b之间的in时刻的区间或者out时刻区间就是其路径。例如AK之间的路径就对应区间ABEEFKABEEFK或者KFBCGGHHIICA。
   2.若lca另有其人，a、b之间的路径为In[a]、Out[b]之间的区间或者In[b]、Out[a]之间的区间。另外，还需额外加上lca！！！考虑EK路径，对应为EFK再加上BB。考虑EHEH之间的路径，对应为EFKKFBCGGH再加上A。

### 树链剖分

对树进行重新编号，使得能将任意一条路径，变为o(logn)段连续区间。

+ 重儿子:子树中节点数最多的根节点是重儿子。
+ 其余点为轻儿子
+ 重边：重儿子与父节点的边。
+ 重链：极大的重边构成的路径

重儿子放置到父节点的重链中

轻儿子放置到子节点的重链中

![image-20220725200322989](D:\none_c\ACM\树链剖分.png)



dfs序:优先遍历重儿子,即可保证重链上的所有的编号是连续的。

定理：树中任意一条路径都可以拆分为O(logn)条重链,即可拆分成O(logn)个连续区间。

算法流程:dfs标记重儿子，然后dfs2找到重链 

时间复杂度:上界是logn。

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=1e5+5;
#define il (id<<1)
#define ir il+1
ll w[maxn],nw[maxn];
int n,m;
int sz[maxn],fa[maxn],son[maxn],dep[maxn],top[maxn];
int nid[maxn],cnt;
struct tree
{
    int l,r;
    ll lz,sum;
}tr[maxn<<2];
vector<int>e[maxn];
void dfs1(int s,int father,int depth)
{
    dep[s]=depth;
    fa[s]=father;sz[s]=1;
    for(auto to:e[s])
    {
        if(to==father)continue;
        dfs1(to,s,depth+1);
        sz[s]+=sz[to];
        if(sz[to]>sz[son[s]])son[s]=to;
    }
}
void dfs2(int s,int t)//用来放重链的起点，根据定理重链的起点是轻链。
{
    nid[s]=++cnt,nw[cnt]=w[s],top[s]=t;
    if(!son[s])return ;//没有重链表示是叶子节点
    dfs2(son[s],t);
    for(auto to:e[s])//遍历轻儿子
    {
        if(to==fa[s]||to==son[s])continue;
        dfs2(to,to);
    }
}
void pushdown(int id)
{
    if(tr[id].lz!=0)
    {
        tr[il].lz+=tr[id].lz;tr[il].sum+=tr[id].lz*(tr[il].r-tr[il].l+1);
        tr[ir].lz+=tr[id].lz;tr[ir].sum+=tr[id].lz*(tr[ir].r-tr[ir].l+1);
        tr[id].lz=0;
    }
}
void pushup(int id)
{
    tr[id].sum=tr[il].sum+tr[ir].sum;
}
void build(int id,int l,int r)
{
    tr[id]={l,r,0,0};
    if(l==r)
    {
        tr[id].sum=nw[r];
        return ;
    }
    int mid=(l+r)>>1;
    build(il,l,mid);
    build(ir,mid+1,r);
    pushup(id);
}
void update(int id,int l,int r,ll y)
{
    if(tr[id].l>=l&&tr[id].r<=r)
    {
        tr[id].lz+=y;
        tr[id].sum+=(tr[id].r-tr[id].l+1)*y;
        return ;
    }
    pushdown(id);
    if(tr[il].r>=l)update(il,l,r,y);
    if(tr[ir].l<=r)update(ir,l,r,y);
    pushup(id);
}
ll querry(int id,int l,int r)
{
    if(tr[id].l>=l&&tr[id].r<=r)
    {
        return tr[id].sum;       
    }
    pushdown(id);
    ll ans=0;
    if(tr[il].r>=l)ans+=querry(il,l,r);
    if(tr[ir].l<=r)ans+=querry(ir,l,r);
    return ans;
}
void update_path(int u,int v,ll k)
{
    while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]])swap(u,v);
        update(1,nid[top[u]],nid[u],k);
        u=fa[top[u]];
    }
    if(dep[u]>dep[v])swap(u,v);
    update(1,nid[u],nid[v],k);
}
void update_tree(int u,ll k)
{
    update(1,nid[u],nid[u]+sz[u]-1,k);
}
ll querry_path(int u,int v)
{
    ll ans=0;
    while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]])swap(u,v);
        ans+=querry(1,nid[top[u]],nid[u]);
        u=fa[top[u]];
    }
    if(dep[u]>dep[v])swap(u,v);
    ans+=querry(1,nid[u],nid[v]);
    return ans;
}
ll querry_tree(int u)
{
    return querry(1,nid[u],nid[u]+sz[u]-1);
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%lld",&w[i]);
    for(int i=1;i<n;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        e[u].push_back(v);
        e[v].push_back(u);
    }
    dfs1(1,-1,1);
    dfs2(1,1);
    build(1,1,n);
    int q;
	scanf("%d",&q);
    while(q--)
    {
        int op;
        scanf("%d",&op);
        if(op==1)
        {
            int u,v,k;
            scanf("%d%d%d",&u,&v,&k);
            update_path(u,v,k);
        }
        else if(op==2)
        {
            int u,k;
            scanf("%d%d",&u,&k);
            update_tree(u,k);
        }
        else if(op==3)
        {
            int u,v;
            scanf("%d%d",&u,&v);
            printf("%lld\n",querry_path(u,v));
        }
        else 
        {
            int u;
            scanf("%d",&u);
            printf("%lld\n",querry_tree(u));
        }
    }
    return 0;
}
```



### 双端队列

```c++
struct Deque {
	int head, rear, max_length;
	int q[DEQUE_SIZE];
	// 构造函数 
	Deque() {
		head = 0;
		rear = 1;
		max_length = DEQUE_SIZE; //最大容量
	}
	// 清空
	void clear() {
		head = 0;
		rear = 1;
	}
	// 判空 
	bool empty() {
		if((head + 1) % max_length == rear) {
			return true;
		}
		return false;
	}
	// 判满 
	bool full() {
		if((rear + 1) % max_length == head) {
			return true;
		}
		return false;
	}
	// 队列长度 
	int size() {
		return (rear - head - 1 + max_length) % max_length;
	}
	// 返回队首元素
	int front() {
		if(empty()) return -1; //队列为空 
		return q[(head + 1) % max_length];
	}
	// 返回队尾元素 
	int back() {
		if(empty()) return -1; //队列为空 
		return q[(rear - 1 + max_length) % max_length];
	} 
	// 队尾插入元素 
	void push_back(int val) {
		if(full()) return; // 队列满了
		q[rear] = val;
		rear = (rear + 1) % max_length; 
	}
	// 队首插入元素
	void push_front(int val) {
		if(full()) return; // 队列满了
		q[head] = val;
		head = (head - 1 + max_length) % max_length; 
	}
	// 队尾删除元素 
	void pop_back() {
		if(empty()) return; //队列为空 
		rear = (rear - 1 + max_length) % max_length;
	}
	// 队首删除元素 
	void pop_front() {
		if(empty()) return; //队列为空 
		head = (head + 1) % max_length;
	}
};

```



### 树上dp

环基图,拆环为树

### 并查集

```c++
int find(int x)
{
if(a[x]==x)return x;
return a[x]=find(a[x]);
}
a[find(x)]=find(y);建立
```

### 手写堆

```c++
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#define ll long long
using namespace std;
const ll p=1e9+7;
ll heap[10000007];//模拟堆
ll a[10000007];
ll hsize=0;//堆的大小，也是堆最后一个元素的编号
inline ll read(){
	ll s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void _insert(ll node,ll num)//插入函数，思路是将元素插入到最后的叶节点，然后往上跳，直到它的父节点小于它时
{
    heap[node]=num;//直接覆盖，省去了判断。若还需继续跳，再在判断中将它重新赋值
    if(heap[node>>1]>num)//判断父节点是否大于它（若大于，则交换）。注意：node等于1时，它的父节点为0，值为0，必然比它小，所以不会再往上跳，所以无需加特判
    {
        heap[node]=heap[node>>1];
        _insert(node>>1,num);//交换父子位置，继续递归
    }
}
inline void _pop(ll node,ll num)//删除函数
{
    heap[node]=num;//类似插入函数，直接先赋值
    if((node<<1)<=hsize&&(num>heap[node<<1]||num>heap[(node<<1)|1]))//如果它有子节点，且至少有一个小于它（及可进行交换）
    {
        heap[node]=heap[node<<1]<heap[(node<<1)|1]?heap[node<<1]:heap[(node<<1)|1];//让更小的与它交换，保证堆的稳定性
        _pop(heap[node<<1]<heap[(node<<1)|1]?node<<1:(node<<1)|1,num);//判断应走哪一个子节点
    }
}
int main()
{
   ll gs;
    ll cz;
    ll crs;
    ll n;n=read();
    for(int i=1;i<=n;i++)
	{
		ll num;
		a[i]=read();
	}
	ll res=0;ll pop=1;
	for(int i=1;i<n;i++)
	{
		ll r1,r2;
		ll q1=1e18,q2=1e18,q3=1e18,q4=1e18;
		if(pop<=n)q1=a[pop];
		if(pop+1<=n)q2=a[pop+1];
		if(hsize==0||q1<heap[1])
		{
			r1=q1,pop++;
			if(hsize==0||q2<heap[1])r2=q2,pop++;
			else r2=heap[1],_pop(1,heap[hsize--]);
		}
		else 
		{
			r1=heap[1],_pop(1,heap[hsize--]);
			if(hsize==0||q1<heap[1])r2=q1,pop++;
			else r2=heap[1],_pop(1,heap[hsize--]);
		}
		
		//cout<<r1<<" "<<r2<<endl;
		res=(res+r1+r2)%p;
		
		_insert(++hsize,r1+r2);
	}
	cout<<res<<endl;
    /*for(int zs=0;zs<gs;zs++)
    {
        scanf("%d",&cz);//三种操作
        if(cz==1)scanf("%d",&crs),_insert(++hsize,crs);
        if(cz==2)printf("%d\n",heap[1]);//堆顶即使最小值
        if(cz==3)_pop(1,heap[hsize--]);//注意++、--的位置（我就在这里卡了好久/(ㄒoㄒ)/~~，30分的同学也有可能是在这里卡的）
    }*/
    return 0;
}

```

### 树状数组

利用lowbit构造伪树形结构，是得修改变成o(log n)

利用c[i]数组存放满足某些点的和，使其整体满足变形二叉树，当需要查询时，取处需要的c[i],这些c[i]相加的记过便是查询的前缀和。

区间查询，单点修改（类似前缀和）

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+5;
int c[maxn];//长度等于数据长度
inline int lowbit(int x){return x&(-x);}//取出x的最低位1
inline void update(int x,int y,int n){//单点更新
    for(int i=x;i<=n;i+=lowbit(i))c[i]+=y;
}
inline int getsum(int x){
    int ans=0;for(int i=x;i;i-=lowbit(i))ans+=c[i];
    return ans;
}
int main()
{
    ios::sync_with_stdio(false);
    int op,n,m,x,y,num;
    cin>>n>>m;
    for(int i=1;i<=n;i++){cin>>num;update(i,num,n);}
    for(int i=1;i<=m;i++){
        cin>>op>>x>>y;
        if(op==1)update(x,y,n);
        else cout<<getsum(y)-getsum(x-1)<<endl;//查询类似差分，就是查询前缀和
    }
    return 0;
}

```

区间修改，单点查询

利用差分数组的思想，将数组$[a_1,a_2,……，a_n]$​转化为$[a_1,a_2-a_1,a_3-a_2,……,a_n-a_{n-1}]$

区间修改类似差分，更改l, r+1;

查修的是前缀和

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn = 1e5 + 5;
int n, m;
ll c[maxn];
int lowbit(int x) { return x & (-x); }
void add(int x,int y)
{
	for (int i = x; i <= n; i += lowbit(i))c[i] += y;
}
ll getsum(int x)
{
	ll ans = 0;for (int i = x; i; i -= lowbit(i))ans += c[i];return ans;
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> n >> m;
	int num1,num2;
	cin >> num1; add(1, num1);
	for (int i = 2; i <= n; i++)cin >> num2, add(i, num2 - num1), num1 = num2;
	while(m--)
	{
		char op;
		cin >> op;
		if(op=='Q')
		{
			int x;
			cin >> x;
			cout << getsum(x) << endl;
		}
		else 
		{
			int l, r, x;
			cin >> l >> r >> x;
			add(l, x); add(r + 1, -x);
		}
	}
	return 0;
}
```



### 线段树

1.简单的线段树
       单点修改加区间查询
       单点修改：先搜索，搜到待修改的点后修改，回溯过程中自下而上修改，时间复杂度logn
       区间查询：返回所有被待查询区间包括的区间，时间复杂度logn
       单点查询和区间修改
       区间修改：在这里线段树存放的是在原基础上增加的num;
       单点查询；自上而下将沿路的num都相加
       2.进阶线段数
       区间修改和区间查询
       区间修改：当发现目前区间被待修改区间覆盖了，就将该区间加上k*长度，并且加上延迟标记；
       区间查询：增加了push_down的操作，将延迟标记传递给子区间，并且增加子区间的sum;这样查询的时间与之前的时间复杂度相同
       乘法线段树
       其他都相同,当有乘有加时需要先乘再加；

### st表

```c++
//ST表 
#include<cstdio>
#include<iostream>
using namespace std;
const int N=100001;
int i,j,m,n,l,r,lg[N],st[N][22];
 int que(int x,int y)
 {
 	int z=lg[y-x+1];
 	return max(st[x][z],st[y-(1<<z)+1][z]);
 }
int main()
{
    cin>>n>>m;
    lg[0]=-1;
    for(i=1;i<=n;++i)
    {
        scanf("%d",&st[i][0]);
        lg[i]=lg[i>>1]+1;
    }
    for(j=1;j<22;++j)
     for(i=1;i+(1<<j)-1<=n;++i)
      st[i][j]=max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
    for(i=1;i<=m;++i)
    {
        scanf("%d%d",&l,&r);
        printf("%d\n",que(l,r));
    }
    return 0;
}
```



## 字符串

string s1;

s1.substr(begin,end);

### 马拉车算法

**马拉车用于解决最长回文子串问题，重点是子串，所以对于求最长回文子串的问题有一种神奇的算法——马拉车算法，神奇就神奇在时间复杂度为O(n)。**

```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int maxn = 1e6 + 5;
char s[maxn * 2], str[maxn * 2];
int Len[maxn * 2], len;
void getstr() {//重定义字符串
	int k = 0;
	str[k++] = '@';//开头加个特殊字符防止越界
	for (int i = 0; i < len; i++) {
		str[k++] = '#';
		str[k++] = s[i];
	}
	str[k++] = '#';
	len = k;
	str[k] = 0;//字符串尾设置为0，防止越界
}
int manacher() {
	int mx = 0, id;//mx为最右边，id为中心点
	int maxx = 0;
	for (int i = 1; i < len; i++) {
		if (mx > i) Len[i] = min(mx - i, Len[2 * id - i]);//判断当前点超没超过mx
		else Len[i] = 1;//超过了就让他等于1，之后再进行查找
		while (str[i + Len[i]] == str[i - Len[i]]) Len[i]++;//判断当前点是不是最长回文子串，不断的向右扩展
		if (Len[i] + i > mx) {//更新mx
			mx = Len[i] + i;
			id = i;//更新中间点
			maxx = max(maxx, Len[i]);//最长回文字串长度
		}
	}
	return (maxx - 1);
}
int main() {
	scanf("%s", s);
	len = strlen(s);
	getstr();
	printf("%d\n",manacher());
	return 0;
}

```



### 字典树（前缀树、单词查找树）

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m;
struct node
{
    int cnt;
    int son[26];
    bool have;
    node()
    {
        cnt=0;
        memset(son,false,sizeof(son));//太大还是别用的好
        have=false;
    }
}trie[maxn];
int num;
void insert(string s)
{
    int v,len=s.length();
    int u=0;
    for(int i=0;i<len;i++)
    {
        v=s[i]-'a';
        if(trie[u].son[v]==0)trie[u].son[v]=++num;
		u=trie[u].son[v];
		trie[u].cnt++;
    }
    trie[u].have=1;
}
int find(string s)
{
    int v,u=0,len=s.length();
    for(int i=0;i<len;i++)
    {
        v=s[i]-'a';
        if(trie[u].son[v]==0)return 3;+
    }
    if(trie[u].have==0)return 3;
    if(trie[u].cnt==0)
    {
        trie[u].cnt++;
        return 1;
    }
    return 2;
}
int main()
{
    ios::sync_with_stdio(false);
    char name[100];
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%s",name);
        insert(name);
    }
    scanf("%d",&m);
    for(int i=1;i<=m;++i)
    {
        scanf("%s",name);
        int p=find(name);
        if(p==1)
            puts("OK");
        else if(p==2)
            puts("REPEAT");
        else if(p==3)
            puts("WRONG");
    }
    return 0;
}
```

###  kmp模式匹配算法

如何理解构造next数组中j=next[j]？

首先明白next数组表示的是下表为当前下标之前的字符串的最长公共子序列。

如： abcabc [0-5]

next[5]表示abcab的最长公共子序列。

构造过程

当$s[i]==s[j]||j==-1$时，i++，j++

失配则j=next[j]

即让j跳到j之前的字符串的最长公共前后缀的前缀的后一个进行匹配。

可以知道处于失配位置j的前方的字符串是k之前的最长前缀，对于K的可能的最长前缀也只会出现在此处。

时间复杂度O（n+m）

定理：假设S的长度为len，则S存在最小循环节，循环节的长度L为len-next[len]，子串为S[0…len-next[len]-1]。

（1）如果len可以被len - next[len]整除，则表明字符串S可以完全由循环节循环组成，循环周期T=len/L。

（2）如果不能，说明还需要再添加几个字母才能补全。需要补的个数是循环个数L-len%L=L-(len-L)%L=L-next[len]%L，L=len-next[len]。

分为3个步骤:
1.prefix_arrary（每一位的存放的是当前字符串的最大公共前后缀；
2.move prefix_arrary(为了之后匹配服务，整体后移，首位补-1)；
3.match;

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+6;
char s1[maxn],s2[maxn];
int nex[maxn];//数组中存放的是下标为i之前的字符串最长公共前后缀的长度。 
int main()
{
	scanf("%s%s",s1,s2);
	nex[0]=nex[1]=0;
	vector<int>ans;
	int len1=strlen(s1),len2=strlen(s2);
	for(int i=1,k=0;i<len2;i++)
	{
		while(k&&s2[i]!=s2[k])k=nex[k];//如果匹配失败，将指针跳回到失配的地方 
		if(s2[i]==s2[k])nex[i+1]=++k;//如果两者相同，则最长公共前后缀。 
		else nex[i+1]=0;//否则
	}
	for(int i=0,k=0;i<len1;i++)
	{
		while(k&&s1[i]!=s2[k])k=nex[k];
		if(s1[i]==s2[k])k++;
		if(k>=len2)cout<<i-len2+2<<endl;		
	}
	cout<<0<<" ";
	for(int i=1,k=0;i<len2;i++)
	{
		while(k&&s2[i]!=s2[k])k=nex[k];
		if(s2[i]==s2[k])nex[i+1]=++k;
		else nex[i+1]=0;
		cout<<nex[i+1]<<" ";
	}
	cout<<endl;
	return 0;
}
```

### AC自动机(树上kmp)

ac自动机：在trie树上增加了失配指针，当匹配失败时便跳转到失配指针指向的地方。

通过该方法避免回溯产生的时间上的损失。

key1:如何构建fail指针？

1.第一层的fail指针指向的是根节点。

2.之后的fail指针指向的是父节点的fail指针指向的结点的子结点中与改结点中相同的结点。

key2:如何得到fail？

fail指针都是向上指的那么我们可以一层一层的处理结点的fail指针，那么下一层的fail指针可以直接继承父节点的fail，无需沿着fail一路向上。

那么利用bfs构建ac自动机是最好的选择。

**Trie图优化**

当我们沿着字典树的某一支路一直匹配下去，但我们发现匹配完了，我们会如何处理指针？

返回到根结点？那么时间复杂度会大大增加。

如何优化？我们可以将匹配结束的结点与其

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e6 + 6;
int tr[maxn][26], fail[maxn], cnt[maxn], q[maxn], id;
char s[maxn];
void build()
{
	int p = 0;
	for(int i=0;s[i];i++)
	{
		int to = s[i] - 'a';
		if (tr[p][to] == 0)tr[p][to] = ++id;
		p = tr[p][to];
	}
	cnt[p]++;
}
void get_fail()
{
	int hh = 0, tt = -1;
	for (int i = 0; i < 26; i++)if (tr[0][i])q[++tt] = tr[0][i];
	while(hh<=tt)
	{
		int ss = q[hh++];
		for(int i=0;i<26;i++)
		{
			int to = tr[ss][i];
			if (to == 0)tr[ss][i] = tr[fail[ss]][i];//如果ss不存在后继to,那么就将to向上指，指向有后继的。
			else fail[to] = tr[fail[ss]][i],q[++tt]=to;//否则则将失配指针指向其父节点的下一个。
		}
	}
}
int main()
{
	int n;
	scanf("%d", &n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s", s);
		build();
	}
	get_fail();
	scanf("%s", s);
	int res = 0;
	for(int i=0,j=0;s[i];i++)
	{
		j = tr[j][s[i] - 'a'];
		int p = j;
		while(p&&~cnt[p])//优化，当发现cnt被搜索过就停止，类似记忆化
		{
			res += cnt[p];
			cnt[p] = -1;
			p = fail[p];
		}
	}
	printf("%d\n", res);
}
/*
4
a
ab
ac
abc
abcd

3
*/
```

拓扑排序优化统计答案

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 5;
const int L = 2e6 + 6;
int tr[maxn][26], cnt[maxn], fail[maxn], ans[maxn], du[maxn], typ[maxn], id, q[maxn], w[maxn];
char s[L], st[L];
map<int, int>m;
void build(int ty)
{
	int p = 0;
	for (int i = 0; s[i]; i++)
	{
		int to = s[i] - 'a';
		if (tr[p][to] == 0)tr[p][to] = ++id;
		p = tr[p][to];
	}
	if (typ[p] == 0)typ[p] = ty;
	m[ty] = typ[p];
}
void get_fail()
{
	int hh = 0, tt = -1;
	for (int i = 0; i < 26; i++)if (tr[0][i])q[++tt] = tr[0][i];
	while (hh <= tt)
	{
		int ss = q[hh++];
		for (int i = 0; i < 26; i++)
		{
			int to = tr[ss][i];
			if (to == 0)tr[ss][i] = tr[fail[ss]][i];
			else fail[to] = tr[fail[ss]][i], q[++tt] = to, du[fail[to]]++;//记录fail[to]的度数。
		}
	}
}
int main()
{
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		scanf("%s", s);
		build(i);
	}
	get_fail();
	scanf("%s", st);
	int hh = 0, tt = -1;
	for (int i = 0, j = 0;  st[i]; i++)
	{
		j = tr[j][st[i] - 'a'];
		w[j] ++;//标记该点被访问了几次
	}
	for (int i = 1; i <= id; i++)if (du[i] == 0)q[++tt] = i;
	while (hh <= tt)
	{
		int ss = q[hh++];
		int to = fail[ss];
		if (to&&to != ss) {
			w[to] += w[ss];
			if (du[to] == 1)q[++tt] = to;
			du[to]--;
		}
	}
	for (int i = 0; i <= id; i++)ans[typ[i]] += w[i];
	for (int i = 1; i <= n; i++)printf("%d\n", ans[m[i]]);
	return 0;
}
```



## 科技的力量

### 模拟退火

```c++
#include <bits/stdc++.h>
#define re register
using namespace std;

inline int read() { //读入优化
    int X=0,w=1; char c=getchar();
    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }
    while (c>='0'&&c<='9') X=(X<<3)+(X<<1)+c-'0',c=getchar();
    return X*w;
}

struct node { int x,y,w; };

node a[1010];
int n,sx,sy;

double ansx,ansy,ansz; //全局最优解的坐标
double ans=1e18,t; //全局最优解、温度
const double delta=0.993;//0.993; //降温系数

inline double calc_energy(double x,double y) { //计算整个系统的能量
    double rt=0;
    for (re int i=1;i<=n;i++) {
        double deltax=x-a[i].x,deltay=y-a[i].y;
        rt+=sqrt(deltax*deltax+deltay*deltay)*a[i].w;
    }
    return rt;
}//如何计算系统能量？

inline void simulate_anneal() { //SA主过程
    double x=ansx,y=ansy;
    t=2000; //初始温度
    while (t>1e-14) {
        double X=x+((rand()<<1)-RAND_MAX)*t;
        double Y=y+((rand()<<1)-RAND_MAX)*t; //得出一个新的坐标
        double now=calc_energy(X,Y);
        double Delta=now-ans;
        if (Delta<0) { //接受
            x=X,y=Y;
            ansx=x,ansy=y,ans=now;
        }
        else if (exp(-Delta/t)*RAND_MAX>rand()) x=X,y=Y; //以一个概率接受
        t*=delta;
    }
}

inline void Solve() { //多跑几遍SA，减小误差
    ansx=(double)sx/n,ansy=(double)sy/n; //从平均值开始更容易接近最优解
    simulate_anneal();
    simulate_anneal();
    simulate_anneal();
    simulate_anneal();
    simulate_anneal();
}

int main() {
    srand(18253517); srand(rand());srand(rand()); //玄学srand
    //cout << RAND_MAX;//32767
    n=read();
    for (re int i=1;i<=n;i++) {
        a[i].x=read(),a[i].y=read(),a[i].w=read();
        sx+=a[i].x,sy+=a[i].y;
    }
    Solve();
    printf("%.3f %.3f\n",ansx,ansy);
    return 0;
}

```

## 小代码，大智慧

### 位运算

按位构造

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    ll x,s,res=1;
    cin>>x>>s;
    for(int i=32;i>=0;i--)
    {
        int xi=(x>>i)&1;
        int si=(s>>i)&1;
        if(xi==1)
        {
            if(si==1)res*=2;
            if(si==0)res=0;
        }
    }
    if((x|0)==s)res--;
    cout<<res<<endl;
    return 0;
}
```

$a+b = a | b + a \& b$







### 树上启发式合并

核心思想，优先访问轻儿子，对于轻儿子，当完成遍历，即得到答案后，选择立即清空，可以避免影响其他子树，最后访问重儿子，重儿子访问之后，不清空，直接向上合并，这样保证向上合并的近可能多，只有以轻儿子为节点的子树会被计算两边。根据树链剖分的思想，轻边最多只有log 个，于是总时间复杂度nlogn(常数小)。

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=1e5+5;
int a[maxn],sz[maxn],son[maxn],vis[maxn];
vector<int>e[maxn];
ll sum=0,ans[maxn];int mx=0;
void dfs1(int s,int fa)
{
    sz[s]=1;
    for(auto to:e[s])
    {
        if(to==fa)continue;
        dfs1(to,s);
        sz[s]+=sz[to];
        if(sz[son[s]]<sz[to])son[s]=to;
    }
}
void update(int s,int fa,int sign,int pson)
{
    vis[a[s]]+=sign;
    if(vis[a[s]]>mx)mx=vis[a[s]],sum=0;
    if(mx==vis[a[s]])sum+=a[s];
    for(auto to:e[s])
    {
        if(to==fa||to==pson)continue;
        update(to,s,sign,pson);
    }
}
void dfs2(int s,int fa,int op)
{
    for(auto to:e[s])
    {
        if(to==fa||to==son[s])continue; 
        dfs2(to,s,0);
    }
    if(son[s])dfs2(son[s],s,1);
    update(s,fa,1,son[s]);
    ans[s]=sum;//更新S
    if(op==0)
    {
        update(s,fa,-1,0),sum=0,mx=0;
    }
}
int main()
{
    ios::sync_with_stdio(false);
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<n;i++)
    {
        int u,v;
        cin>>u>>v;
        //scanf("%d%d")
        e[u].push_back(v);
        e[v].push_back(u);
    }
    dfs1(1,0);
    dfs2(1,0,1);
    for(int i=1;i<=n;i++)cout<<ans[i]<<" ";cout<<'\n';
    return 0;
}
```

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cstdlib>
using namespace std;
typedef long long ll;
const int mod=1e9+7;
const int N=100010,M=1e6+10;
int n,a[N],cnt[M][22][2];
int h[N],e[N<<1],ne[N<<1],idx;
void add(int a,int b)
{
    e[idx]=b;ne[idx]=h[a];h[a]=idx++;
}
int son[N],sz[N];

void dfs(int u,int fa)
{
    sz[u]=1;
    for(int i=h[u];~i;i=ne[i])
    {
        int v=e[i];
        if(v==fa) continue;
        dfs(v,u);
        sz[u]+=sz[v];
        if(sz[v]>sz[son[u]]) son[u]=v;
    }
}
ll flag,ans;
int num;
void count(int u,int fa,int val)
{
    for(int i=0;i<=20;++i)//f[i][j][0]表示点权为i的节点中 节点编号的第j位是0的个数，最终答案是节点编号的异或和，这样节能快速求结果了，f[i][j][1]同理
    	cnt[a[u]][i][(u>>i)&1]+=val;
    num+=val;
    for(int i=h[u];~i;i=ne[i])
    {
        int v=e[i];
        if(v==fa||v==flag) continue;
        count(v,u,val); 
    }
}
void get(int u,int fa,int t)//统计以t为lca，以u为根的子树产生的贡献
{
    int val=a[t]^a[u];
    if(val<M)//避免越界，大于最大值一定没有贡献
	    for(int i=0;i<=20;++i)
	    {
	    	int p=((u>>i)&1);
	    	ans+=1ll*cnt[val][i][p^1]*(1<<i); // 点权为val的节点中第i位有多少个 p^1 就会产生多少个 （1<<i）的贡献
		}
    for(int i=h[u];~i;i=ne[i])
    {
        int v=e[i];
        if(v==fa) continue;
        get(v,u,t);
    }
}

void dfs(int u,int fa,int op)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int v=e[i];
        if(v==fa||v==son[u]) continue;
        dfs(v,u,0);
    }
    if(son[u])
    {
        dfs(son[u],u,1); 
        flag=son[u];//标记重儿子，不然count时会漏掉u节点轻儿子的重儿子
    }
	/*count(u,fa,1); 模板是这样写的，就是将以u为根的子树全部统计一遍，根据
题意改为下边那样:将每个子树分别添加进去，添加之前计算该子树与已经添加过的子树产生的贡献。最初是只有重儿子没有被清空，所以重儿子不用添加，子树被添加之后，还要将u节点加进去才能和模板一样
*/	
    for(int i=h[u];~i;i=ne[i])
    {
    	int v=e[i];
    	if(v==fa||v==son[u]) continue;
    	get(v,u,u);
    	count(v,u,1);
	}
	for(int i=0;i<=20;++i)//将u节点加进去
    	cnt[a[u]][i][(u>>i)&1]+=1;
    
    flag=0;//记得清空重儿子避免对下面的清空子树产生影响
    if(!op)
    {
        count(u,fa,-1);
    }
}

int main()
{
    memset(h,-1,sizeof h);
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d",a+i);
    for(int i=1;i<n;++i)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);
    }
    dfs(1,-1);
    dfs(1,-1,0);
    printf("%lld",ans);
    return 0;
}
```



### 最小表示法

求给定字符串循环移位后的最小字典序

```c++
#include<bits/stdc++.h>
using namespace std;
string min_p(string &s)
{
    int n=s.length();
    s=s+s;
    int p1=0,p2=1;
    while(p1<n&&p2<n)
    {
        int f=1;
        for(int i=0;i<n;i++)
        {
            if(s[p1+i]==s[p2+i])continue;
            else if(s[p1+i]<s[p2+i])
            {
                p2=p2+i+1;
                f=0;
                break;
            }   
            else 
            {
                p1=p2;p2=p2+i+1;
                f=0;
                break;
            }         
        }
    }
    if(p1>p2)swap(p1,p2);
    return s.substr(p1,n);
}
int main()
{
    ios::sync_with_stdio(false);
    string s1,s2,n1,n2;
    cin>>s1>>s2;
    int n=s1.length();
    n1=min_p(s1);n2=min_p(s2);
    if(n1==n2)
    {
        cout<<"YES"<<'\n'<<n1<<'\n';
    }
    else cout<<'\n';
    return 0;
}
```

### 自然幂级数求和

### 题意

求$ ∑_{i=1}^ni^k \ mod(1e9+7),n≤10^9,k≤10^6∑_{i=1}^ni^k \ mod(1e9+7),n≤10^9,k≤10^6$.

[CF622F](https://www.luogu.org/problem/CF622F)

### 分析

易知答案是一个 k+1k+1 次多项式，我们找 k+2 个值代进去，然后拉格朗日插值。

n+1 组点值对 (xi,yi)，得到 nn 次多项式 ff 的拉格朗日插值公式为：



f(x)=∑i=0nyi∏j≠ix−xjxi−xjf(x)=∑i=0nyi∏j≠ix−xjxi−xj



时间复杂度为 O(n2)，

如果我们取 n 个连续的值，这样可以预处理阶乘，复杂度降至 O(n)O(n)，

在这题中复杂度为 O(klogmod)O(klogmod)，其中 O(logmod)O(logmod)为求逆元的时间。



```
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll mod = 1e9 + 7;
const int maxk = 1000000 + 10;
ll n, k;

ll qpow(ll m, ll n, ll mod)
{
    ll res = 1;
    while (n > 0)
    {
        if (n & 1)
            res = (res * m) % mod;
        m = (m * m) % mod;
        n = n >> 1;
    }
    return res;
}

ll fac[maxk], y[maxk];  //前k+2项前缀和都已经算好
ll Largrange()
{
    fac[0]=fac[1]=1,y[1]=1;
    for(int i=2;i<=k+2;i++) fac[i]=fac[i-1]*i%mod;      //预处理阶乘
    for(int i=2;i<=k+2;i++) y[i]=(y[i-1]+qpow(i,k, mod))%mod;  //预处理求出每一项的结果
    if(n<=k+2)  return y[n];
    ll ans = 0, prod = 1, sig;
    for(ll i = n-k-2; i <= n-1;i++)  prod = prod * i % mod;
    for(ll i = 1;i <= k+2;i++)
    {
        ll fz = prod * qpow(n-i, mod-2, mod) % mod;
        ll fm = qpow(fac[i-1] * fac[k+2-i] % mod, mod-2, mod);
        if((k+2-i) % 2 == 0)  sig = 1;
        else sig = -1;
        ans = (ans + sig*y[i]*fz%mod*fm%mod + 2*mod) % mod;
    }
    return ans;
;}


int main()
{
    scanf("%lld%lld", &n, &k);
    printf("%lld\n", Largrange());

    return 0;
}
```

















